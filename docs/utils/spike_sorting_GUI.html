<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>blechpy.utils.spike_sorting_GUI API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>blechpy.utils.spike_sorting_GUI</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import tkinter as tk
import sys
from tkinter import ttk
import numpy as np
import matplotlib
from blechpy.utils import userIO, tk_widgets as tkw
matplotlib.use(&#39;TkAgg&#39;)
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from blechpy.utils.tk_widgets import ScrollFrame, window_center
from blechpy.analysis.blech_clustering import SpikeSorter


class SpikeSorterGUI(ttk.Frame):
    def __init__(self, parent, spike_sorter, *args, **kwargs):
        tk.Frame.__init__(self, parent, *args, **kwargs)
        self.root = parent
        self.root.style = ttk.Style()
        self.root.style.theme_use(&#39;clam&#39;)
        self.root.geometry(&#39;915x800&#39;)
        self.pack(fill=&#39;both&#39;, expand=True)
        window_center(self.root)

        self.sorter = spike_sorter
        self.sorter._shell = False
        self.electrode = spike_sorter.electrode
        self.initUI()

    def initUI(self):
        # Make layout
        row1 = ttk.Frame(self)
        row2 = ttk.Frame(self)

        figs = ttk.Frame(row2)
        ui = ttk.Frame(row2)

        solution_row = ttk.Frame(ui)
        click_row = ttk.Frame(ui)

        checks = ttk.Frame(click_row)
        buttons = ttk.Frame(click_row)

        buttons.pack(side=&#39;right&#39;, padx=10)
        checks.pack(side=&#39;right&#39;, padx=10)

        solution_row.pack(side=&#39;top&#39;, anchor=&#39;n&#39;, pady=30)
        click_row.pack(side=&#39;top&#39;, anchor=&#39;n&#39;)

        figs.pack(side=&#39;left&#39;, fill=&#39;both&#39;, expand=True)
        ui.pack(side=&#39;left&#39;)

        row1.pack(side=&#39;top&#39;)
        row2.pack(side=&#39;top&#39;, fill=&#39;both&#39;, expand=True, anchor=&#39;n&#39;)

        # Make title
        title = tk.Label(row1, text=&#39;Electrode %i&#39; % self.electrode)
        title.pack(side=&#39;top&#39;, fill=&#39;x&#39;)

        # Make user interface pane

        # Select solution
        solutions = self.sorter.get_possible_solutions()
        self._solution_var = tk.IntVar(self, max(solutions))
        solution_drop = ttk.OptionMenu(solution_row, self._solution_var,
                                       *solutions)
        solution_drop.pack(side=&#39;right&#39;)
        ttk.Label(solution_row, text=&#39;Solution Clusters: &#39;).pack(side=&#39;right&#39;)

        self._solution_var.trace(&#39;w&#39;, self.change_solution)

        # Set sorter to max solutions
        self.sorter.set_active_clusters(self._solution_var.get())

        # Check boxes
        cluster_choices = list(range(self._solution_var.get()))
        self._check_bar = CheckBar(checks, cluster_choices)
        ttk.Label(checks, text=&#39;Clusters:&#39;).pack(side=&#39;top&#39;, pady=10)
        self._check_bar.pack()

        # Buttons
        merge = ttk.Button(buttons, text=&#39;Merge&#39;, command=self.merge_clusters)
        split = ttk.Button(buttons, text=&#39;Split&#39;, command=self.split_clusters)
        splitUMAP = ttk.Button(buttons, text=&#39;UMAP Split (Slow)&#39;,
                               command=self.umap_split_clusters)
        save = ttk.Button(buttons, text=&#39;Save Cells&#39;, command=self.save)
        viewWaves = ttk.Button(buttons, text=&#39;View Waves&#39;, command=self.view_waves)
        # viewRecWaves = ttk.Button(buttons, text=&#39;View Waves by Rec&#39;,
        #                           command=self.view_waves_by_rec)
        viewTimeWaves = ttk.Button(buttons, text=&#39;View Waves over Time&#39;,
                                  command=self.view_waves_over_time)
        viewPCA = ttk.Button(buttons, text=&#39;View PCA&#39;, command=self.view_pca)
        viewUMAP = ttk.Button(buttons, text=&#39;View UMAP&#39;, command=self.view_umap)
        viewWAVELET = ttk.Button(buttons, text=&#39;View Wavelets&#39;, command=self.view_wavelets)
        viewRaster = ttk.Button(buttons, text=&#39;View Raster&#39;, command=self.view_raster)
        viewISI = ttk.Button(buttons, text=&#39;View ISI&#39;, command=self.view_ISI)
        viewXCORR = ttk.Button(buttons, text=&#39;View XCorr&#39;, command=self.view_xcorr)
        viewACORR = ttk.Button(buttons, text=&#39;View AutoCorr&#39;, command=self.view_acorr)
        discard = ttk.Button(buttons, text=&#39;Discard Clusters&#39;, command=self.discard_clusters)
        self._undo_button = ttk.Button(buttons, text=&#39;Undo&#39;, command=self.undo)
        merge.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        split.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        splitUMAP.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        save.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        # viewRecWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewTimeWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewPCA.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewUMAP.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewWAVELET.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewRaster.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewISI.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewACORR.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewXCORR.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        discard.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        self._undo_button.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        self._undo_button.config(state=&#39;disabled&#39;)

        self._ui_frame = ui

        # Figures
        self._wavepane = WaveformPane(figs)
        self._wavepane.pack(side=&#39;left&#39;, fill=&#39;both&#39;, expand=True, padx=10, pady=10)
        self.update()


    def update(self):
        if self.sorter._last_action is not None:
            self._undo_button.config(text=&#39;Undo &#39; + self.sorter._last_action,
                                     state=&#39;normal&#39;)
        else:
            self._undo_button.config(text=&#39;Undo&#39;, state=&#39;disabled&#39;)

        # Check active clusters
        clusters = list(range(len(self.sorter._active)))

        # Update cluster checkbar
        self._check_bar.updateChoices(clusters)

        # Update waveforms
        wave_dict = {}
        for i in clusters:
            wave_dict[i] = self.sorter.get_mean_waveform(i)

        self._wavepane.update(wave_dict)

    def undo(self):
        self.sorter.undo()
        self.update()

    def change_solution(self, *args):
        solutions = self._solution_var.get()
        self.sorter.set_active_clusters(solutions)
        self.update()

    def merge_clusters(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) &lt; 2:
            return

        self.sorter.merge_clusters(chosen)
        self.update()

    def umap_split_clusters(self, *args):
        self.split_clusters(umap=True)

    def split_clusters(self, *args, umap=False):
        chosen = self._check_bar.get_selected()
        if len(chosen) != 1:
            return

        if isinstance(chosen, list):
            chosen = chosen[0]

        params = {&#39;n_iterations&#39;: 1000,
                  &#39;n_restarts&#39;: 10,
                  &#39;thresh&#39;: 10e-6,
                  &#39;n_clusters&#39;: int}

        popup = userIO.fill_dict_popup(params, master=self.root,
                                       prompt=&#39;Input parameters for splitting&#39;)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        params = popup.output
        if popup.cancelled or params[&#39;n_clusters&#39;] is None:
            return

        new_clusts = self.sorter.split_cluster(chosen, params[&#39;n_iterations&#39;],
                                               params[&#39;n_restarts&#39;],
                                               params[&#39;thresh&#39;],
                                               params[&#39;n_clusters&#39;],
                                               store_split=True,
                                               umap=umap)

        choices = [&#39;%i&#39; % i for i in range(len(new_clusts))]
        popup = tkw.ListSelectPopup(choices, self.root,
                                    &#39;Select split clusters to keep.\n&#39;
                                    &#39;Cancel to undo split.&#39;, multi_select=True)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        chosen = list(map(int, popup.output))

        self.sorter.set_split(chosen)
        self.update()

    def save(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        cell_types = {}
        for i in chosen:
            cell_types[i] = {&#39;single_unit&#39;: False, &#39;pyramidal&#39;: False,
                             &#39;interneuron&#39;: False}

        popup  = userIO.fill_dict_popup(cell_types, master=self.root)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        cell_types = popup.output
        if popup.cancelled:
            return

        single = [cell_types[i][&#39;single_unit&#39;] for i in sorted(cell_types.keys())]
        pyramidal = [cell_types[i][&#39;pyramidal&#39;] for i in sorted(cell_types.keys())]
        interneuron = [cell_types[i][&#39;interneuron&#39;] for i in sorted(cell_types.keys())]
        self.sorter.save_clusters(chosen, single, pyramidal, interneuron)
        self.update()

    def view_waves(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_waveforms(chosen)

    def view_waves_by_rec(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) != 1:
            return

        if isinstance(chosen, list):
            chosen = chosen[0]

        self.sorter.plot_cluster_waveforms_by_rec(chosen)

    def view_waves_over_time(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) != 1:
            return

        if isinstance(chosen, list):
            chosen = chosen[0]

        params = {&#39;interval&#39;: int}
        popup = userIO.fill_dict_popup(params, master=self.root,
                                       prompt=&#39;Input time interval for segments (in seconds)&#39;)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        params = popup.output
        if popup.cancelled or params[&#39;interval&#39;] is None:
            return

        self.sorter.plot_cluster_waveforms_over_time(chosen, params[&#39;interval&#39;])

    def view_pca(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_pca(chosen)

    def view_umap(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.disable_all()
        self.sorter.plot_clusters_umap(chosen)
        self.enable_all()

    def view_wavelets(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.disable_all()
        self.sorter.plot_clusters_wavelets(chosen)
        self.enable_all()

    def view_ISI(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_ISI(chosen)

    def view_raster(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_raster(chosen)

    def view_acorr(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_acorr(chosen)

    def view_xcorr(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_xcorr(chosen)

    def discard_clusters(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.discard_clusters(chosen)
        self.update()

    def undo_save(self, *args):
        self.sorter.undo_last_save()
        self.update()

    def cstate(self,state,widget=None):
        if widget is None:
            widget = self
        if widget.winfo_children:
            for w in widget.winfo_children():
                try:
                    w.state((state,))
                except:
                    pass
                self.cstate(state,widget=w)

    def enable_all(self):
        self.cstate(&#39;!disabled&#39;)

    def disable_all(self):
        self.cstate(&#39;disabled&#39;)



class CheckBar(ttk.Frame):
    def __init__(self, parent=None, choices=[]):
        tk.Frame.__init__(self, parent)
        self.choices = choices
        title = ttk.Label(self, text=&#39;Clusters&#39;)
        self.choice_rows = []
        self.choice_vars = []
        self.updateChoices()

    def updateChoices(self, new_choices=[]):
        if len(new_choices) &gt; 0:
            self.choices = new_choices

        if len(self.choice_rows) &gt; 0:
            for row in self.choice_rows:
                row.destroy()

        self.choice_vars = [tk.IntVar(self, 0) for i in self.choices]
        self.choice_rows = []
        for choice, var in zip(self.choices, self.choice_vars):
            check = tk.Checkbutton(self, text=str(choice), variable=var)
            check.pack(fill=&#39;x&#39;, anchor=&#39;n&#39;, pady=5)
            self.choice_rows.append(check)

    def get_selected(self):
        checked = [i.get() for i in self.choice_vars]
        out = [self.choices[i] for i, j in enumerate(checked) if j==1]
        return out


def make_waveform_plot(wave, wave_std, n_waves=None,index=None):
    minima = min(wave)
    fig, ax = plt.subplots(figsize=(3, 2))
    ax.xaxis.set_tick_params(bottom=False, top=False, labelbottom=False)
    ax.yaxis.set_tick_params(bottom=False, top=False, labelbottom=False)
    fig.tight_layout()
    X = list(range(len(wave)))
    ax.fill_between(X, [i+j for i,j in zip(wave, wave_std)],
                    [i-j for i,j in zip(wave, wave_std)],
                    alpha=0.4)
    ax.plot(X, wave, linewidth=3)
    ax.autoscale(axis=&#39;x&#39;, tight=True)
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    tmp_str = &#39;Amp: %0.1f&#39; % minima
    if n_waves:
        tmp_str += &#39;\nN Waves: %i&#39; % n_waves

    ax.text(xlim[1]-200, ylim[0] + 0.1*abs(ylim[0]), tmp_str,
            fontsize=10)

    if index is not None:
        ax.text(xlim[0] + 10, ylim[0] + 0.05*abs(ylim[0]), str(index),
                fontweight=&#39;bold&#39;, fontsize=14)

    return fig


class WaveformPane(ttk.Frame):
    def __init__(self, parent, wave_dict=None, **kwargs):
        self._wave_dict = wave_dict
        tk.Frame.__init__(self, parent, **kwargs)
        self.parent = parent
        self._fig_rows = []
        self._all_figs = []
        self._fig_canvases = []
        self.initUI()

    def initUI(self):
        self.scrollpane = ScrollFrame(self)
        self.scrollpane.pack(fill=&#39;both&#39;, expand=True, padx=10, pady=10)
        self.update()

    def update(self, wave_dict=None):
        if wave_dict is not None:
            self._wave_dict = wave_dict

        if len(self._fig_rows) &gt; 0:
            for row in self._fig_rows:
                row.destroy()

        if len(self._all_figs) &gt; 0:
            for f in self._all_figs:
                plt.close(f)

        if len(self._fig_canvases) &gt; 0:
            for canvas in self._fig_canvases:
                canvas.get_tk_widget().destroy()

        self._fig_rows = []
        self._all_figs = []
        self._fig_canvases = []

        if self._wave_dict is None:
            return

        row = None
        for k, v in self._wave_dict.items():
            wave = v[0]
            wave_std = v[1]
            n_waves = v[2]
            fig = make_waveform_plot(wave, wave_std, n_waves=n_waves, index=k)
            self._all_figs.append(fig)

            if row is None:
                row = ttk.Frame(self.scrollpane.viewport)
                row.pack(side=&#39;top&#39;, fill=&#39;x&#39;)
                self._fig_rows.append(row)
                side = &#39;left&#39;
                delFlag = False
            else:
                side = &#39;right&#39;
                delFlag = True

            canvas = FigureCanvasTkAgg(fig, row)
            canvas.draw()
            canvas.get_tk_widget().pack(side=side)
            self._fig_canvases.append(canvas)
            if delFlag:
                row = None

        self.scrollpane.bind_children_to_mouse()


class DummySorter(object):
    def __init__(self, electrode, shell=False):
        self.electrode = electrode
        # Match recording directory ordering to clustering
        self._active = None
        self._previous=None
        self._waves = {}
        self._shell = shell

    def set_active_clusters(self, solution_num):
        clusters = [i for i in range(solution_num)]
        self._active = clusters

    def save_clusters(self, target_clusters, single_unit, pyramidal, interneuron):
        &#39;&#39;&#39;Saves active clusters as cells, write them to the h5_files in the
        appropriate recording directories

        Parameters
        ----------
        target_clusters: list of int
            indicies of active clusters to save
        single_unit : list of bool
            elements in list must correspond to elements in active clusters
        pyramidal : list of bool
        interneuron : list of bool
        &#39;&#39;&#39;
        if self._active is None:
            return

        clusters = [self._active[i] for i in target_clusters]
        for clust, single, pyr, intr in zip(clusters, single_unit,
                                            pyramidal, interneuon):
            out_str = [&#39;Saved cluster %i.&#39; % clust]
            if pyr:
                out_str.append(&#39;Pyramidal&#39;)

            if intr:
                out_str.append(&#39;Interneuron&#39;)

            if single:
                out_str.append(&#39;Single-Unit&#39;)

            print(&#39; &#39;.join(out_str))

        self._active = [self._active[i] for i in range(len(self._active))
                        if i not in target_clusters]
        self._previous = clusters

    def undo_last_save(self):
        if self._previous is None:
            return

        last_saved = self._last_saved
        self._active.extend(self._previous)
        self._previous = None

    def split_cluster(self, target_clust, n_iter, n_restart, thresh, n_clust):
        &#39;&#39;&#39;splits the target active cluster using a GMM
        &#39;&#39;&#39;
        if target_clust &gt;= len(self._active):
            raise ValueError(&#39;Invalid target. Only %i active clusters&#39; % len(self._active))

        cluster = self._active.pop(target_clust)
        new_clusts = [cluster*10+i for i in range(n_clust)]
        selection_list = [&#39;all&#39;] + [&#39;%i&#39; % i for i in range(len(new_clusts))]
        prompt = &#39;Select split clusters to keep&#39;
        ans = userIO.select_from_list(prompt, selection_list,
                                      multi_select=True, shell=self._shell)
        if ans is None or &#39;all&#39; in ans:
            print(&#39;Reset to before split&#39;)
            self._active.insert(target_cluster, cluster)
        else:
            self._waves.pop(clusters)
            keepers = [new_clusts[int(i)] for i in ans]
            self._active.extend(keepers)

    def merge_clusters(self, target_clusters):
        if any([i &gt;= len(self._active) for i in target_clusters]):
            raise ValueError(&#39;Target cluster is out of range.&#39;)

        clusters = [self._active[i] for i in target_clusters]
        new_clust = sum([pow(10,i)*j for i,j in enumerate(clusters)])
        self._active = [self._active[i] for i in range(len(self._active))
                        if i not in target_clusters]
        for c in clusters:
            self._waves.pop(c)

        self._active.append(new_clust)

    def discard_clusters(self, target_clusters):
        self._active = [self._active[i] for i in range(len(self._active))
                        if i not in target_clusters]
        for i in target_clusters:
            self._waves.pop(i)

    def plot_clusters_waveforms(self, target_clusters):
        pass

    def plot_clusters_pca(self, target_clusters):
        pass

    def plot_clusters_raster(self, target_clusters):
        pass

    def plot_clusters_ISI(self, target_clusters):
        pass

    def get_mean_waveform(self, target_cluster):
        &#39;&#39;&#39;Returns mean waveform of target_cluster in active clusters. Also
        returns SEM of waveforms
        &#39;&#39;&#39;
        cluster = self._active[target_cluster]
        if self._waves.get(cluster) is not None:
            return self._waves[cluster][0], self._waves[cluster][1]

        amp = np.random.randint(-60, -20, 1)[0]
        start = np.random.randint(0, 20, 1)[0]
        rebound = np.random.randint(-10,40,1)[0]
        steps_to_rise = np.random.randint(5,30,1)[0]
        tmp = np.array([start, start, amp, rebound, start])
        xp = np.array([0, 10, 15, 15+steps_to_rise, 45])
        x = np.arange(0,45)
        wave = np.interp(x,xp,tmp)
        wave_sem = np.random.randint(1,10,45)
        self._waves[cluster] = (wave, wave_sem)
        return wave, wave_sem

    def get_possible_solutions(self):
        return list(range(8))

def launch_sorter_GUI(sorter):
    root = tk.Tk()
    sorter_GUI = SpikeSorterGUI(root, sorter)
    return root, sorter_GUI</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="blechpy.utils.spike_sorting_GUI.launch_sorter_GUI"><code class="name flex">
<span>def <span class="ident">launch_sorter_GUI</span></span>(<span>sorter)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def launch_sorter_GUI(sorter):
    root = tk.Tk()
    sorter_GUI = SpikeSorterGUI(root, sorter)
    return root, sorter_GUI</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.make_waveform_plot"><code class="name flex">
<span>def <span class="ident">make_waveform_plot</span></span>(<span>wave, wave_std, n_waves=None, index=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_waveform_plot(wave, wave_std, n_waves=None,index=None):
    minima = min(wave)
    fig, ax = plt.subplots(figsize=(3, 2))
    ax.xaxis.set_tick_params(bottom=False, top=False, labelbottom=False)
    ax.yaxis.set_tick_params(bottom=False, top=False, labelbottom=False)
    fig.tight_layout()
    X = list(range(len(wave)))
    ax.fill_between(X, [i+j for i,j in zip(wave, wave_std)],
                    [i-j for i,j in zip(wave, wave_std)],
                    alpha=0.4)
    ax.plot(X, wave, linewidth=3)
    ax.autoscale(axis=&#39;x&#39;, tight=True)
    xlim = ax.get_xlim()
    ylim = ax.get_ylim()
    tmp_str = &#39;Amp: %0.1f&#39; % minima
    if n_waves:
        tmp_str += &#39;\nN Waves: %i&#39; % n_waves

    ax.text(xlim[1]-200, ylim[0] + 0.1*abs(ylim[0]), tmp_str,
            fontsize=10)

    if index is not None:
        ax.text(xlim[0] + 10, ylim[0] + 0.05*abs(ylim[0]), str(index),
                fontweight=&#39;bold&#39;, fontsize=14)

    return fig</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="blechpy.utils.spike_sorting_GUI.CheckBar"><code class="flex name class">
<span>class <span class="ident">CheckBar</span></span>
<span>(</span><span>parent=None, choices=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Frame widget is a container, used to group other widgets
together.</p>
<p>Construct a Ttk Frame with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>borderwidth, relief, padding, width, height
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckBar(ttk.Frame):
    def __init__(self, parent=None, choices=[]):
        tk.Frame.__init__(self, parent)
        self.choices = choices
        title = ttk.Label(self, text=&#39;Clusters&#39;)
        self.choice_rows = []
        self.choice_vars = []
        self.updateChoices()

    def updateChoices(self, new_choices=[]):
        if len(new_choices) &gt; 0:
            self.choices = new_choices

        if len(self.choice_rows) &gt; 0:
            for row in self.choice_rows:
                row.destroy()

        self.choice_vars = [tk.IntVar(self, 0) for i in self.choices]
        self.choice_rows = []
        for choice, var in zip(self.choices, self.choice_vars):
            check = tk.Checkbutton(self, text=str(choice), variable=var)
            check.pack(fill=&#39;x&#39;, anchor=&#39;n&#39;, pady=5)
            self.choice_rows.append(check)

    def get_selected(self):
        checked = [i.get() for i in self.choice_vars]
        out = [self.choices[i] for i, j in enumerate(checked) if j==1]
        return out</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Frame</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="blechpy.utils.spike_sorting_GUI.CheckBar.get_selected"><code class="name flex">
<span>def <span class="ident">get_selected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selected(self):
    checked = [i.get() for i in self.choice_vars]
    out = [self.choices[i] for i, j in enumerate(checked) if j==1]
    return out</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.CheckBar.updateChoices"><code class="name flex">
<span>def <span class="ident">updateChoices</span></span>(<span>self, new_choices=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateChoices(self, new_choices=[]):
    if len(new_choices) &gt; 0:
        self.choices = new_choices

    if len(self.choice_rows) &gt; 0:
        for row in self.choice_rows:
            row.destroy()

    self.choice_vars = [tk.IntVar(self, 0) for i in self.choices]
    self.choice_rows = []
    for choice, var in zip(self.choices, self.choice_vars):
        check = tk.Checkbutton(self, text=str(choice), variable=var)
        check.pack(fill=&#39;x&#39;, anchor=&#39;n&#39;, pady=5)
        self.choice_rows.append(check)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter"><code class="flex name class">
<span>class <span class="ident">DummySorter</span></span>
<span>(</span><span>electrode, shell=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DummySorter(object):
    def __init__(self, electrode, shell=False):
        self.electrode = electrode
        # Match recording directory ordering to clustering
        self._active = None
        self._previous=None
        self._waves = {}
        self._shell = shell

    def set_active_clusters(self, solution_num):
        clusters = [i for i in range(solution_num)]
        self._active = clusters

    def save_clusters(self, target_clusters, single_unit, pyramidal, interneuron):
        &#39;&#39;&#39;Saves active clusters as cells, write them to the h5_files in the
        appropriate recording directories

        Parameters
        ----------
        target_clusters: list of int
            indicies of active clusters to save
        single_unit : list of bool
            elements in list must correspond to elements in active clusters
        pyramidal : list of bool
        interneuron : list of bool
        &#39;&#39;&#39;
        if self._active is None:
            return

        clusters = [self._active[i] for i in target_clusters]
        for clust, single, pyr, intr in zip(clusters, single_unit,
                                            pyramidal, interneuon):
            out_str = [&#39;Saved cluster %i.&#39; % clust]
            if pyr:
                out_str.append(&#39;Pyramidal&#39;)

            if intr:
                out_str.append(&#39;Interneuron&#39;)

            if single:
                out_str.append(&#39;Single-Unit&#39;)

            print(&#39; &#39;.join(out_str))

        self._active = [self._active[i] for i in range(len(self._active))
                        if i not in target_clusters]
        self._previous = clusters

    def undo_last_save(self):
        if self._previous is None:
            return

        last_saved = self._last_saved
        self._active.extend(self._previous)
        self._previous = None

    def split_cluster(self, target_clust, n_iter, n_restart, thresh, n_clust):
        &#39;&#39;&#39;splits the target active cluster using a GMM
        &#39;&#39;&#39;
        if target_clust &gt;= len(self._active):
            raise ValueError(&#39;Invalid target. Only %i active clusters&#39; % len(self._active))

        cluster = self._active.pop(target_clust)
        new_clusts = [cluster*10+i for i in range(n_clust)]
        selection_list = [&#39;all&#39;] + [&#39;%i&#39; % i for i in range(len(new_clusts))]
        prompt = &#39;Select split clusters to keep&#39;
        ans = userIO.select_from_list(prompt, selection_list,
                                      multi_select=True, shell=self._shell)
        if ans is None or &#39;all&#39; in ans:
            print(&#39;Reset to before split&#39;)
            self._active.insert(target_cluster, cluster)
        else:
            self._waves.pop(clusters)
            keepers = [new_clusts[int(i)] for i in ans]
            self._active.extend(keepers)

    def merge_clusters(self, target_clusters):
        if any([i &gt;= len(self._active) for i in target_clusters]):
            raise ValueError(&#39;Target cluster is out of range.&#39;)

        clusters = [self._active[i] for i in target_clusters]
        new_clust = sum([pow(10,i)*j for i,j in enumerate(clusters)])
        self._active = [self._active[i] for i in range(len(self._active))
                        if i not in target_clusters]
        for c in clusters:
            self._waves.pop(c)

        self._active.append(new_clust)

    def discard_clusters(self, target_clusters):
        self._active = [self._active[i] for i in range(len(self._active))
                        if i not in target_clusters]
        for i in target_clusters:
            self._waves.pop(i)

    def plot_clusters_waveforms(self, target_clusters):
        pass

    def plot_clusters_pca(self, target_clusters):
        pass

    def plot_clusters_raster(self, target_clusters):
        pass

    def plot_clusters_ISI(self, target_clusters):
        pass

    def get_mean_waveform(self, target_cluster):
        &#39;&#39;&#39;Returns mean waveform of target_cluster in active clusters. Also
        returns SEM of waveforms
        &#39;&#39;&#39;
        cluster = self._active[target_cluster]
        if self._waves.get(cluster) is not None:
            return self._waves[cluster][0], self._waves[cluster][1]

        amp = np.random.randint(-60, -20, 1)[0]
        start = np.random.randint(0, 20, 1)[0]
        rebound = np.random.randint(-10,40,1)[0]
        steps_to_rise = np.random.randint(5,30,1)[0]
        tmp = np.array([start, start, amp, rebound, start])
        xp = np.array([0, 10, 15, 15+steps_to_rise, 45])
        x = np.arange(0,45)
        wave = np.interp(x,xp,tmp)
        wave_sem = np.random.randint(1,10,45)
        self._waves[cluster] = (wave, wave_sem)
        return wave, wave_sem

    def get_possible_solutions(self):
        return list(range(8))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.discard_clusters"><code class="name flex">
<span>def <span class="ident">discard_clusters</span></span>(<span>self, target_clusters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discard_clusters(self, target_clusters):
    self._active = [self._active[i] for i in range(len(self._active))
                    if i not in target_clusters]
    for i in target_clusters:
        self._waves.pop(i)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.get_mean_waveform"><code class="name flex">
<span>def <span class="ident">get_mean_waveform</span></span>(<span>self, target_cluster)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns mean waveform of target_cluster in active clusters. Also
returns SEM of waveforms</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mean_waveform(self, target_cluster):
    &#39;&#39;&#39;Returns mean waveform of target_cluster in active clusters. Also
    returns SEM of waveforms
    &#39;&#39;&#39;
    cluster = self._active[target_cluster]
    if self._waves.get(cluster) is not None:
        return self._waves[cluster][0], self._waves[cluster][1]

    amp = np.random.randint(-60, -20, 1)[0]
    start = np.random.randint(0, 20, 1)[0]
    rebound = np.random.randint(-10,40,1)[0]
    steps_to_rise = np.random.randint(5,30,1)[0]
    tmp = np.array([start, start, amp, rebound, start])
    xp = np.array([0, 10, 15, 15+steps_to_rise, 45])
    x = np.arange(0,45)
    wave = np.interp(x,xp,tmp)
    wave_sem = np.random.randint(1,10,45)
    self._waves[cluster] = (wave, wave_sem)
    return wave, wave_sem</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.get_possible_solutions"><code class="name flex">
<span>def <span class="ident">get_possible_solutions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_possible_solutions(self):
    return list(range(8))</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.merge_clusters"><code class="name flex">
<span>def <span class="ident">merge_clusters</span></span>(<span>self, target_clusters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_clusters(self, target_clusters):
    if any([i &gt;= len(self._active) for i in target_clusters]):
        raise ValueError(&#39;Target cluster is out of range.&#39;)

    clusters = [self._active[i] for i in target_clusters]
    new_clust = sum([pow(10,i)*j for i,j in enumerate(clusters)])
    self._active = [self._active[i] for i in range(len(self._active))
                    if i not in target_clusters]
    for c in clusters:
        self._waves.pop(c)

    self._active.append(new_clust)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_ISI"><code class="name flex">
<span>def <span class="ident">plot_clusters_ISI</span></span>(<span>self, target_clusters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clusters_ISI(self, target_clusters):
    pass</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_pca"><code class="name flex">
<span>def <span class="ident">plot_clusters_pca</span></span>(<span>self, target_clusters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clusters_pca(self, target_clusters):
    pass</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_raster"><code class="name flex">
<span>def <span class="ident">plot_clusters_raster</span></span>(<span>self, target_clusters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clusters_raster(self, target_clusters):
    pass</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_waveforms"><code class="name flex">
<span>def <span class="ident">plot_clusters_waveforms</span></span>(<span>self, target_clusters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_clusters_waveforms(self, target_clusters):
    pass</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.save_clusters"><code class="name flex">
<span>def <span class="ident">save_clusters</span></span>(<span>self, target_clusters, single_unit, pyramidal, interneuron)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves active clusters as cells, write them to the h5_files in the
appropriate recording directories</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target_clusters</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>indicies of active clusters to save</dd>
<dt><strong><code>single_unit</code></strong> :&ensp;<code>list</code> of <code>bool</code></dt>
<dd>elements in list must correspond to elements in active clusters</dd>
<dt><strong><code>pyramidal</code></strong> :&ensp;<code>list</code> of <code>bool</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>interneuron</code></strong> :&ensp;<code>list</code> of <code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_clusters(self, target_clusters, single_unit, pyramidal, interneuron):
    &#39;&#39;&#39;Saves active clusters as cells, write them to the h5_files in the
    appropriate recording directories

    Parameters
    ----------
    target_clusters: list of int
        indicies of active clusters to save
    single_unit : list of bool
        elements in list must correspond to elements in active clusters
    pyramidal : list of bool
    interneuron : list of bool
    &#39;&#39;&#39;
    if self._active is None:
        return

    clusters = [self._active[i] for i in target_clusters]
    for clust, single, pyr, intr in zip(clusters, single_unit,
                                        pyramidal, interneuon):
        out_str = [&#39;Saved cluster %i.&#39; % clust]
        if pyr:
            out_str.append(&#39;Pyramidal&#39;)

        if intr:
            out_str.append(&#39;Interneuron&#39;)

        if single:
            out_str.append(&#39;Single-Unit&#39;)

        print(&#39; &#39;.join(out_str))

    self._active = [self._active[i] for i in range(len(self._active))
                    if i not in target_clusters]
    self._previous = clusters</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.set_active_clusters"><code class="name flex">
<span>def <span class="ident">set_active_clusters</span></span>(<span>self, solution_num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_active_clusters(self, solution_num):
    clusters = [i for i in range(solution_num)]
    self._active = clusters</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.split_cluster"><code class="name flex">
<span>def <span class="ident">split_cluster</span></span>(<span>self, target_clust, n_iter, n_restart, thresh, n_clust)</span>
</code></dt>
<dd>
<div class="desc"><p>splits the target active cluster using a GMM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_cluster(self, target_clust, n_iter, n_restart, thresh, n_clust):
    &#39;&#39;&#39;splits the target active cluster using a GMM
    &#39;&#39;&#39;
    if target_clust &gt;= len(self._active):
        raise ValueError(&#39;Invalid target. Only %i active clusters&#39; % len(self._active))

    cluster = self._active.pop(target_clust)
    new_clusts = [cluster*10+i for i in range(n_clust)]
    selection_list = [&#39;all&#39;] + [&#39;%i&#39; % i for i in range(len(new_clusts))]
    prompt = &#39;Select split clusters to keep&#39;
    ans = userIO.select_from_list(prompt, selection_list,
                                  multi_select=True, shell=self._shell)
    if ans is None or &#39;all&#39; in ans:
        print(&#39;Reset to before split&#39;)
        self._active.insert(target_cluster, cluster)
    else:
        self._waves.pop(clusters)
        keepers = [new_clusts[int(i)] for i in ans]
        self._active.extend(keepers)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.DummySorter.undo_last_save"><code class="name flex">
<span>def <span class="ident">undo_last_save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo_last_save(self):
    if self._previous is None:
        return

    last_saved = self._last_saved
    self._active.extend(self._previous)
    self._previous = None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI"><code class="flex name class">
<span>class <span class="ident">SpikeSorterGUI</span></span>
<span>(</span><span>parent, spike_sorter, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Frame widget is a container, used to group other widgets
together.</p>
<p>Construct a Ttk Frame with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>borderwidth, relief, padding, width, height
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpikeSorterGUI(ttk.Frame):
    def __init__(self, parent, spike_sorter, *args, **kwargs):
        tk.Frame.__init__(self, parent, *args, **kwargs)
        self.root = parent
        self.root.style = ttk.Style()
        self.root.style.theme_use(&#39;clam&#39;)
        self.root.geometry(&#39;915x800&#39;)
        self.pack(fill=&#39;both&#39;, expand=True)
        window_center(self.root)

        self.sorter = spike_sorter
        self.sorter._shell = False
        self.electrode = spike_sorter.electrode
        self.initUI()

    def initUI(self):
        # Make layout
        row1 = ttk.Frame(self)
        row2 = ttk.Frame(self)

        figs = ttk.Frame(row2)
        ui = ttk.Frame(row2)

        solution_row = ttk.Frame(ui)
        click_row = ttk.Frame(ui)

        checks = ttk.Frame(click_row)
        buttons = ttk.Frame(click_row)

        buttons.pack(side=&#39;right&#39;, padx=10)
        checks.pack(side=&#39;right&#39;, padx=10)

        solution_row.pack(side=&#39;top&#39;, anchor=&#39;n&#39;, pady=30)
        click_row.pack(side=&#39;top&#39;, anchor=&#39;n&#39;)

        figs.pack(side=&#39;left&#39;, fill=&#39;both&#39;, expand=True)
        ui.pack(side=&#39;left&#39;)

        row1.pack(side=&#39;top&#39;)
        row2.pack(side=&#39;top&#39;, fill=&#39;both&#39;, expand=True, anchor=&#39;n&#39;)

        # Make title
        title = tk.Label(row1, text=&#39;Electrode %i&#39; % self.electrode)
        title.pack(side=&#39;top&#39;, fill=&#39;x&#39;)

        # Make user interface pane

        # Select solution
        solutions = self.sorter.get_possible_solutions()
        self._solution_var = tk.IntVar(self, max(solutions))
        solution_drop = ttk.OptionMenu(solution_row, self._solution_var,
                                       *solutions)
        solution_drop.pack(side=&#39;right&#39;)
        ttk.Label(solution_row, text=&#39;Solution Clusters: &#39;).pack(side=&#39;right&#39;)

        self._solution_var.trace(&#39;w&#39;, self.change_solution)

        # Set sorter to max solutions
        self.sorter.set_active_clusters(self._solution_var.get())

        # Check boxes
        cluster_choices = list(range(self._solution_var.get()))
        self._check_bar = CheckBar(checks, cluster_choices)
        ttk.Label(checks, text=&#39;Clusters:&#39;).pack(side=&#39;top&#39;, pady=10)
        self._check_bar.pack()

        # Buttons
        merge = ttk.Button(buttons, text=&#39;Merge&#39;, command=self.merge_clusters)
        split = ttk.Button(buttons, text=&#39;Split&#39;, command=self.split_clusters)
        splitUMAP = ttk.Button(buttons, text=&#39;UMAP Split (Slow)&#39;,
                               command=self.umap_split_clusters)
        save = ttk.Button(buttons, text=&#39;Save Cells&#39;, command=self.save)
        viewWaves = ttk.Button(buttons, text=&#39;View Waves&#39;, command=self.view_waves)
        # viewRecWaves = ttk.Button(buttons, text=&#39;View Waves by Rec&#39;,
        #                           command=self.view_waves_by_rec)
        viewTimeWaves = ttk.Button(buttons, text=&#39;View Waves over Time&#39;,
                                  command=self.view_waves_over_time)
        viewPCA = ttk.Button(buttons, text=&#39;View PCA&#39;, command=self.view_pca)
        viewUMAP = ttk.Button(buttons, text=&#39;View UMAP&#39;, command=self.view_umap)
        viewWAVELET = ttk.Button(buttons, text=&#39;View Wavelets&#39;, command=self.view_wavelets)
        viewRaster = ttk.Button(buttons, text=&#39;View Raster&#39;, command=self.view_raster)
        viewISI = ttk.Button(buttons, text=&#39;View ISI&#39;, command=self.view_ISI)
        viewXCORR = ttk.Button(buttons, text=&#39;View XCorr&#39;, command=self.view_xcorr)
        viewACORR = ttk.Button(buttons, text=&#39;View AutoCorr&#39;, command=self.view_acorr)
        discard = ttk.Button(buttons, text=&#39;Discard Clusters&#39;, command=self.discard_clusters)
        self._undo_button = ttk.Button(buttons, text=&#39;Undo&#39;, command=self.undo)
        merge.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        split.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        splitUMAP.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        save.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        # viewRecWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewTimeWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewPCA.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewUMAP.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewWAVELET.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewRaster.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewISI.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewACORR.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        viewXCORR.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        discard.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        self._undo_button.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
        self._undo_button.config(state=&#39;disabled&#39;)

        self._ui_frame = ui

        # Figures
        self._wavepane = WaveformPane(figs)
        self._wavepane.pack(side=&#39;left&#39;, fill=&#39;both&#39;, expand=True, padx=10, pady=10)
        self.update()


    def update(self):
        if self.sorter._last_action is not None:
            self._undo_button.config(text=&#39;Undo &#39; + self.sorter._last_action,
                                     state=&#39;normal&#39;)
        else:
            self._undo_button.config(text=&#39;Undo&#39;, state=&#39;disabled&#39;)

        # Check active clusters
        clusters = list(range(len(self.sorter._active)))

        # Update cluster checkbar
        self._check_bar.updateChoices(clusters)

        # Update waveforms
        wave_dict = {}
        for i in clusters:
            wave_dict[i] = self.sorter.get_mean_waveform(i)

        self._wavepane.update(wave_dict)

    def undo(self):
        self.sorter.undo()
        self.update()

    def change_solution(self, *args):
        solutions = self._solution_var.get()
        self.sorter.set_active_clusters(solutions)
        self.update()

    def merge_clusters(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) &lt; 2:
            return

        self.sorter.merge_clusters(chosen)
        self.update()

    def umap_split_clusters(self, *args):
        self.split_clusters(umap=True)

    def split_clusters(self, *args, umap=False):
        chosen = self._check_bar.get_selected()
        if len(chosen) != 1:
            return

        if isinstance(chosen, list):
            chosen = chosen[0]

        params = {&#39;n_iterations&#39;: 1000,
                  &#39;n_restarts&#39;: 10,
                  &#39;thresh&#39;: 10e-6,
                  &#39;n_clusters&#39;: int}

        popup = userIO.fill_dict_popup(params, master=self.root,
                                       prompt=&#39;Input parameters for splitting&#39;)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        params = popup.output
        if popup.cancelled or params[&#39;n_clusters&#39;] is None:
            return

        new_clusts = self.sorter.split_cluster(chosen, params[&#39;n_iterations&#39;],
                                               params[&#39;n_restarts&#39;],
                                               params[&#39;thresh&#39;],
                                               params[&#39;n_clusters&#39;],
                                               store_split=True,
                                               umap=umap)

        choices = [&#39;%i&#39; % i for i in range(len(new_clusts))]
        popup = tkw.ListSelectPopup(choices, self.root,
                                    &#39;Select split clusters to keep.\n&#39;
                                    &#39;Cancel to undo split.&#39;, multi_select=True)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        chosen = list(map(int, popup.output))

        self.sorter.set_split(chosen)
        self.update()

    def save(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        cell_types = {}
        for i in chosen:
            cell_types[i] = {&#39;single_unit&#39;: False, &#39;pyramidal&#39;: False,
                             &#39;interneuron&#39;: False}

        popup  = userIO.fill_dict_popup(cell_types, master=self.root)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        cell_types = popup.output
        if popup.cancelled:
            return

        single = [cell_types[i][&#39;single_unit&#39;] for i in sorted(cell_types.keys())]
        pyramidal = [cell_types[i][&#39;pyramidal&#39;] for i in sorted(cell_types.keys())]
        interneuron = [cell_types[i][&#39;interneuron&#39;] for i in sorted(cell_types.keys())]
        self.sorter.save_clusters(chosen, single, pyramidal, interneuron)
        self.update()

    def view_waves(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_waveforms(chosen)

    def view_waves_by_rec(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) != 1:
            return

        if isinstance(chosen, list):
            chosen = chosen[0]

        self.sorter.plot_cluster_waveforms_by_rec(chosen)

    def view_waves_over_time(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) != 1:
            return

        if isinstance(chosen, list):
            chosen = chosen[0]

        params = {&#39;interval&#39;: int}
        popup = userIO.fill_dict_popup(params, master=self.root,
                                       prompt=&#39;Input time interval for segments (in seconds)&#39;)
        self.disable_all()
        self.root.wait_window(popup.root)
        self.enable_all()
        params = popup.output
        if popup.cancelled or params[&#39;interval&#39;] is None:
            return

        self.sorter.plot_cluster_waveforms_over_time(chosen, params[&#39;interval&#39;])

    def view_pca(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_pca(chosen)

    def view_umap(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.disable_all()
        self.sorter.plot_clusters_umap(chosen)
        self.enable_all()

    def view_wavelets(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.disable_all()
        self.sorter.plot_clusters_wavelets(chosen)
        self.enable_all()

    def view_ISI(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_ISI(chosen)

    def view_raster(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_raster(chosen)

    def view_acorr(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_acorr(chosen)

    def view_xcorr(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.plot_clusters_xcorr(chosen)

    def discard_clusters(self, *args):
        chosen = self._check_bar.get_selected()
        if len(chosen) == 0:
            return

        self.sorter.discard_clusters(chosen)
        self.update()

    def undo_save(self, *args):
        self.sorter.undo_last_save()
        self.update()

    def cstate(self,state,widget=None):
        if widget is None:
            widget = self
        if widget.winfo_children:
            for w in widget.winfo_children():
                try:
                    w.state((state,))
                except:
                    pass
                self.cstate(state,widget=w)

    def enable_all(self):
        self.cstate(&#39;!disabled&#39;)

    def disable_all(self):
        self.cstate(&#39;disabled&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Frame</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.change_solution"><code class="name flex">
<span>def <span class="ident">change_solution</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_solution(self, *args):
    solutions = self._solution_var.get()
    self.sorter.set_active_clusters(solutions)
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.cstate"><code class="name flex">
<span>def <span class="ident">cstate</span></span>(<span>self, state, widget=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cstate(self,state,widget=None):
    if widget is None:
        widget = self
    if widget.winfo_children:
        for w in widget.winfo_children():
            try:
                w.state((state,))
            except:
                pass
            self.cstate(state,widget=w)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.disable_all"><code class="name flex">
<span>def <span class="ident">disable_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_all(self):
    self.cstate(&#39;disabled&#39;)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.discard_clusters"><code class="name flex">
<span>def <span class="ident">discard_clusters</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discard_clusters(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.sorter.discard_clusters(chosen)
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.enable_all"><code class="name flex">
<span>def <span class="ident">enable_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_all(self):
    self.cstate(&#39;!disabled&#39;)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    # Make layout
    row1 = ttk.Frame(self)
    row2 = ttk.Frame(self)

    figs = ttk.Frame(row2)
    ui = ttk.Frame(row2)

    solution_row = ttk.Frame(ui)
    click_row = ttk.Frame(ui)

    checks = ttk.Frame(click_row)
    buttons = ttk.Frame(click_row)

    buttons.pack(side=&#39;right&#39;, padx=10)
    checks.pack(side=&#39;right&#39;, padx=10)

    solution_row.pack(side=&#39;top&#39;, anchor=&#39;n&#39;, pady=30)
    click_row.pack(side=&#39;top&#39;, anchor=&#39;n&#39;)

    figs.pack(side=&#39;left&#39;, fill=&#39;both&#39;, expand=True)
    ui.pack(side=&#39;left&#39;)

    row1.pack(side=&#39;top&#39;)
    row2.pack(side=&#39;top&#39;, fill=&#39;both&#39;, expand=True, anchor=&#39;n&#39;)

    # Make title
    title = tk.Label(row1, text=&#39;Electrode %i&#39; % self.electrode)
    title.pack(side=&#39;top&#39;, fill=&#39;x&#39;)

    # Make user interface pane

    # Select solution
    solutions = self.sorter.get_possible_solutions()
    self._solution_var = tk.IntVar(self, max(solutions))
    solution_drop = ttk.OptionMenu(solution_row, self._solution_var,
                                   *solutions)
    solution_drop.pack(side=&#39;right&#39;)
    ttk.Label(solution_row, text=&#39;Solution Clusters: &#39;).pack(side=&#39;right&#39;)

    self._solution_var.trace(&#39;w&#39;, self.change_solution)

    # Set sorter to max solutions
    self.sorter.set_active_clusters(self._solution_var.get())

    # Check boxes
    cluster_choices = list(range(self._solution_var.get()))
    self._check_bar = CheckBar(checks, cluster_choices)
    ttk.Label(checks, text=&#39;Clusters:&#39;).pack(side=&#39;top&#39;, pady=10)
    self._check_bar.pack()

    # Buttons
    merge = ttk.Button(buttons, text=&#39;Merge&#39;, command=self.merge_clusters)
    split = ttk.Button(buttons, text=&#39;Split&#39;, command=self.split_clusters)
    splitUMAP = ttk.Button(buttons, text=&#39;UMAP Split (Slow)&#39;,
                           command=self.umap_split_clusters)
    save = ttk.Button(buttons, text=&#39;Save Cells&#39;, command=self.save)
    viewWaves = ttk.Button(buttons, text=&#39;View Waves&#39;, command=self.view_waves)
    # viewRecWaves = ttk.Button(buttons, text=&#39;View Waves by Rec&#39;,
    #                           command=self.view_waves_by_rec)
    viewTimeWaves = ttk.Button(buttons, text=&#39;View Waves over Time&#39;,
                              command=self.view_waves_over_time)
    viewPCA = ttk.Button(buttons, text=&#39;View PCA&#39;, command=self.view_pca)
    viewUMAP = ttk.Button(buttons, text=&#39;View UMAP&#39;, command=self.view_umap)
    viewWAVELET = ttk.Button(buttons, text=&#39;View Wavelets&#39;, command=self.view_wavelets)
    viewRaster = ttk.Button(buttons, text=&#39;View Raster&#39;, command=self.view_raster)
    viewISI = ttk.Button(buttons, text=&#39;View ISI&#39;, command=self.view_ISI)
    viewXCORR = ttk.Button(buttons, text=&#39;View XCorr&#39;, command=self.view_xcorr)
    viewACORR = ttk.Button(buttons, text=&#39;View AutoCorr&#39;, command=self.view_acorr)
    discard = ttk.Button(buttons, text=&#39;Discard Clusters&#39;, command=self.discard_clusters)
    self._undo_button = ttk.Button(buttons, text=&#39;Undo&#39;, command=self.undo)
    merge.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    split.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    splitUMAP.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    save.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    # viewRecWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewTimeWaves.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewPCA.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewUMAP.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewWAVELET.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewRaster.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewISI.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewACORR.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    viewXCORR.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    discard.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    self._undo_button.pack(side=&#39;top&#39;, fill=&#39;x&#39;, pady=5)
    self._undo_button.config(state=&#39;disabled&#39;)

    self._ui_frame = ui

    # Figures
    self._wavepane = WaveformPane(figs)
    self._wavepane.pack(side=&#39;left&#39;, fill=&#39;both&#39;, expand=True, padx=10, pady=10)
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.merge_clusters"><code class="name flex">
<span>def <span class="ident">merge_clusters</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_clusters(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) &lt; 2:
        return

    self.sorter.merge_clusters(chosen)
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    cell_types = {}
    for i in chosen:
        cell_types[i] = {&#39;single_unit&#39;: False, &#39;pyramidal&#39;: False,
                         &#39;interneuron&#39;: False}

    popup  = userIO.fill_dict_popup(cell_types, master=self.root)
    self.disable_all()
    self.root.wait_window(popup.root)
    self.enable_all()
    cell_types = popup.output
    if popup.cancelled:
        return

    single = [cell_types[i][&#39;single_unit&#39;] for i in sorted(cell_types.keys())]
    pyramidal = [cell_types[i][&#39;pyramidal&#39;] for i in sorted(cell_types.keys())]
    interneuron = [cell_types[i][&#39;interneuron&#39;] for i in sorted(cell_types.keys())]
    self.sorter.save_clusters(chosen, single, pyramidal, interneuron)
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.split_clusters"><code class="name flex">
<span>def <span class="ident">split_clusters</span></span>(<span>self, *args, umap=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_clusters(self, *args, umap=False):
    chosen = self._check_bar.get_selected()
    if len(chosen) != 1:
        return

    if isinstance(chosen, list):
        chosen = chosen[0]

    params = {&#39;n_iterations&#39;: 1000,
              &#39;n_restarts&#39;: 10,
              &#39;thresh&#39;: 10e-6,
              &#39;n_clusters&#39;: int}

    popup = userIO.fill_dict_popup(params, master=self.root,
                                   prompt=&#39;Input parameters for splitting&#39;)
    self.disable_all()
    self.root.wait_window(popup.root)
    self.enable_all()
    params = popup.output
    if popup.cancelled or params[&#39;n_clusters&#39;] is None:
        return

    new_clusts = self.sorter.split_cluster(chosen, params[&#39;n_iterations&#39;],
                                           params[&#39;n_restarts&#39;],
                                           params[&#39;thresh&#39;],
                                           params[&#39;n_clusters&#39;],
                                           store_split=True,
                                           umap=umap)

    choices = [&#39;%i&#39; % i for i in range(len(new_clusts))]
    popup = tkw.ListSelectPopup(choices, self.root,
                                &#39;Select split clusters to keep.\n&#39;
                                &#39;Cancel to undo split.&#39;, multi_select=True)
    self.disable_all()
    self.root.wait_window(popup.root)
    self.enable_all()
    chosen = list(map(int, popup.output))

    self.sorter.set_split(chosen)
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.umap_split_clusters"><code class="name flex">
<span>def <span class="ident">umap_split_clusters</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def umap_split_clusters(self, *args):
    self.split_clusters(umap=True)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo(self):
    self.sorter.undo()
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.undo_save"><code class="name flex">
<span>def <span class="ident">undo_save</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo_save(self, *args):
    self.sorter.undo_last_save()
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enter event loop until all pending events have been processed by Tcl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    if self.sorter._last_action is not None:
        self._undo_button.config(text=&#39;Undo &#39; + self.sorter._last_action,
                                 state=&#39;normal&#39;)
    else:
        self._undo_button.config(text=&#39;Undo&#39;, state=&#39;disabled&#39;)

    # Check active clusters
    clusters = list(range(len(self.sorter._active)))

    # Update cluster checkbar
    self._check_bar.updateChoices(clusters)

    # Update waveforms
    wave_dict = {}
    for i in clusters:
        wave_dict[i] = self.sorter.get_mean_waveform(i)

    self._wavepane.update(wave_dict)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_ISI"><code class="name flex">
<span>def <span class="ident">view_ISI</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_ISI(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.sorter.plot_clusters_ISI(chosen)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_acorr"><code class="name flex">
<span>def <span class="ident">view_acorr</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_acorr(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.sorter.plot_clusters_acorr(chosen)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_pca"><code class="name flex">
<span>def <span class="ident">view_pca</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_pca(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.sorter.plot_clusters_pca(chosen)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_raster"><code class="name flex">
<span>def <span class="ident">view_raster</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_raster(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.sorter.plot_clusters_raster(chosen)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_umap"><code class="name flex">
<span>def <span class="ident">view_umap</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_umap(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.disable_all()
    self.sorter.plot_clusters_umap(chosen)
    self.enable_all()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_wavelets"><code class="name flex">
<span>def <span class="ident">view_wavelets</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_wavelets(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.disable_all()
    self.sorter.plot_clusters_wavelets(chosen)
    self.enable_all()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves"><code class="name flex">
<span>def <span class="ident">view_waves</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_waves(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.sorter.plot_clusters_waveforms(chosen)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves_by_rec"><code class="name flex">
<span>def <span class="ident">view_waves_by_rec</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_waves_by_rec(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) != 1:
        return

    if isinstance(chosen, list):
        chosen = chosen[0]

    self.sorter.plot_cluster_waveforms_by_rec(chosen)</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves_over_time"><code class="name flex">
<span>def <span class="ident">view_waves_over_time</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_waves_over_time(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) != 1:
        return

    if isinstance(chosen, list):
        chosen = chosen[0]

    params = {&#39;interval&#39;: int}
    popup = userIO.fill_dict_popup(params, master=self.root,
                                   prompt=&#39;Input time interval for segments (in seconds)&#39;)
    self.disable_all()
    self.root.wait_window(popup.root)
    self.enable_all()
    params = popup.output
    if popup.cancelled or params[&#39;interval&#39;] is None:
        return

    self.sorter.plot_cluster_waveforms_over_time(chosen, params[&#39;interval&#39;])</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_xcorr"><code class="name flex">
<span>def <span class="ident">view_xcorr</span></span>(<span>self, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view_xcorr(self, *args):
    chosen = self._check_bar.get_selected()
    if len(chosen) == 0:
        return

    self.sorter.plot_clusters_xcorr(chosen)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.WaveformPane"><code class="flex name class">
<span>class <span class="ident">WaveformPane</span></span>
<span>(</span><span>parent, wave_dict=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ttk Frame widget is a container, used to group other widgets
together.</p>
<p>Construct a Ttk Frame with parent master.</p>
<p>STANDARD OPTIONS</p>
<pre><code>class, cursor, style, takefocus
</code></pre>
<p>WIDGET-SPECIFIC OPTIONS</p>
<pre><code>borderwidth, relief, padding, width, height
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WaveformPane(ttk.Frame):
    def __init__(self, parent, wave_dict=None, **kwargs):
        self._wave_dict = wave_dict
        tk.Frame.__init__(self, parent, **kwargs)
        self.parent = parent
        self._fig_rows = []
        self._all_figs = []
        self._fig_canvases = []
        self.initUI()

    def initUI(self):
        self.scrollpane = ScrollFrame(self)
        self.scrollpane.pack(fill=&#39;both&#39;, expand=True, padx=10, pady=10)
        self.update()

    def update(self, wave_dict=None):
        if wave_dict is not None:
            self._wave_dict = wave_dict

        if len(self._fig_rows) &gt; 0:
            for row in self._fig_rows:
                row.destroy()

        if len(self._all_figs) &gt; 0:
            for f in self._all_figs:
                plt.close(f)

        if len(self._fig_canvases) &gt; 0:
            for canvas in self._fig_canvases:
                canvas.get_tk_widget().destroy()

        self._fig_rows = []
        self._all_figs = []
        self._fig_canvases = []

        if self._wave_dict is None:
            return

        row = None
        for k, v in self._wave_dict.items():
            wave = v[0]
            wave_std = v[1]
            n_waves = v[2]
            fig = make_waveform_plot(wave, wave_std, n_waves=n_waves, index=k)
            self._all_figs.append(fig)

            if row is None:
                row = ttk.Frame(self.scrollpane.viewport)
                row.pack(side=&#39;top&#39;, fill=&#39;x&#39;)
                self._fig_rows.append(row)
                side = &#39;left&#39;
                delFlag = False
            else:
                side = &#39;right&#39;
                delFlag = True

            canvas = FigureCanvasTkAgg(fig, row)
            canvas.draw()
            canvas.get_tk_widget().pack(side=side)
            self._fig_canvases.append(canvas)
            if delFlag:
                row = None

        self.scrollpane.bind_children_to_mouse()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.ttk.Frame</li>
<li>tkinter.ttk.Widget</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="blechpy.utils.spike_sorting_GUI.WaveformPane.initUI"><code class="name flex">
<span>def <span class="ident">initUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initUI(self):
    self.scrollpane = ScrollFrame(self)
    self.scrollpane.pack(fill=&#39;both&#39;, expand=True, padx=10, pady=10)
    self.update()</code></pre>
</details>
</dd>
<dt id="blechpy.utils.spike_sorting_GUI.WaveformPane.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, wave_dict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Enter event loop until all pending events have been processed by Tcl.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, wave_dict=None):
    if wave_dict is not None:
        self._wave_dict = wave_dict

    if len(self._fig_rows) &gt; 0:
        for row in self._fig_rows:
            row.destroy()

    if len(self._all_figs) &gt; 0:
        for f in self._all_figs:
            plt.close(f)

    if len(self._fig_canvases) &gt; 0:
        for canvas in self._fig_canvases:
            canvas.get_tk_widget().destroy()

    self._fig_rows = []
    self._all_figs = []
    self._fig_canvases = []

    if self._wave_dict is None:
        return

    row = None
    for k, v in self._wave_dict.items():
        wave = v[0]
        wave_std = v[1]
        n_waves = v[2]
        fig = make_waveform_plot(wave, wave_std, n_waves=n_waves, index=k)
        self._all_figs.append(fig)

        if row is None:
            row = ttk.Frame(self.scrollpane.viewport)
            row.pack(side=&#39;top&#39;, fill=&#39;x&#39;)
            self._fig_rows.append(row)
            side = &#39;left&#39;
            delFlag = False
        else:
            side = &#39;right&#39;
            delFlag = True

        canvas = FigureCanvasTkAgg(fig, row)
        canvas.draw()
        canvas.get_tk_widget().pack(side=side)
        self._fig_canvases.append(canvas)
        if delFlag:
            row = None

    self.scrollpane.bind_children_to_mouse()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="blechpy.utils" href="index.html">blechpy.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="blechpy.utils.spike_sorting_GUI.launch_sorter_GUI" href="#blechpy.utils.spike_sorting_GUI.launch_sorter_GUI">launch_sorter_GUI</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.make_waveform_plot" href="#blechpy.utils.spike_sorting_GUI.make_waveform_plot">make_waveform_plot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="blechpy.utils.spike_sorting_GUI.CheckBar" href="#blechpy.utils.spike_sorting_GUI.CheckBar">CheckBar</a></code></h4>
<ul class="">
<li><code><a title="blechpy.utils.spike_sorting_GUI.CheckBar.get_selected" href="#blechpy.utils.spike_sorting_GUI.CheckBar.get_selected">get_selected</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.CheckBar.updateChoices" href="#blechpy.utils.spike_sorting_GUI.CheckBar.updateChoices">updateChoices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter" href="#blechpy.utils.spike_sorting_GUI.DummySorter">DummySorter</a></code></h4>
<ul class="">
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.discard_clusters" href="#blechpy.utils.spike_sorting_GUI.DummySorter.discard_clusters">discard_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.get_mean_waveform" href="#blechpy.utils.spike_sorting_GUI.DummySorter.get_mean_waveform">get_mean_waveform</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.get_possible_solutions" href="#blechpy.utils.spike_sorting_GUI.DummySorter.get_possible_solutions">get_possible_solutions</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.merge_clusters" href="#blechpy.utils.spike_sorting_GUI.DummySorter.merge_clusters">merge_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_ISI" href="#blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_ISI">plot_clusters_ISI</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_pca" href="#blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_pca">plot_clusters_pca</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_raster" href="#blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_raster">plot_clusters_raster</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_waveforms" href="#blechpy.utils.spike_sorting_GUI.DummySorter.plot_clusters_waveforms">plot_clusters_waveforms</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.save_clusters" href="#blechpy.utils.spike_sorting_GUI.DummySorter.save_clusters">save_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.set_active_clusters" href="#blechpy.utils.spike_sorting_GUI.DummySorter.set_active_clusters">set_active_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.split_cluster" href="#blechpy.utils.spike_sorting_GUI.DummySorter.split_cluster">split_cluster</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.DummySorter.undo_last_save" href="#blechpy.utils.spike_sorting_GUI.DummySorter.undo_last_save">undo_last_save</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI">SpikeSorterGUI</a></code></h4>
<ul class="">
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.change_solution" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.change_solution">change_solution</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.cstate" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.cstate">cstate</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.disable_all" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.disable_all">disable_all</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.discard_clusters" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.discard_clusters">discard_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.enable_all" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.enable_all">enable_all</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.initUI" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.initUI">initUI</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.merge_clusters" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.merge_clusters">merge_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.save" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.save">save</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.split_clusters" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.split_clusters">split_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.umap_split_clusters" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.umap_split_clusters">umap_split_clusters</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.undo" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.undo">undo</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.undo_save" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.undo_save">undo_save</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.update" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.update">update</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_ISI" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_ISI">view_ISI</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_acorr" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_acorr">view_acorr</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_pca" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_pca">view_pca</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_raster" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_raster">view_raster</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_umap" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_umap">view_umap</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_wavelets" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_wavelets">view_wavelets</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves">view_waves</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves_by_rec" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves_by_rec">view_waves_by_rec</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves_over_time" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_waves_over_time">view_waves_over_time</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_xcorr" href="#blechpy.utils.spike_sorting_GUI.SpikeSorterGUI.view_xcorr">view_xcorr</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="blechpy.utils.spike_sorting_GUI.WaveformPane" href="#blechpy.utils.spike_sorting_GUI.WaveformPane">WaveformPane</a></code></h4>
<ul class="">
<li><code><a title="blechpy.utils.spike_sorting_GUI.WaveformPane.initUI" href="#blechpy.utils.spike_sorting_GUI.WaveformPane.initUI">initUI</a></code></li>
<li><code><a title="blechpy.utils.spike_sorting_GUI.WaveformPane.update" href="#blechpy.utils.spike_sorting_GUI.WaveformPane.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>
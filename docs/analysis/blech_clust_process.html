<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>blechpy.analysis.blech_clust_process API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>blechpy.analysis.blech_clust_process</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import shutil
import os
import tables
import numpy as np
import sys
import pylab as plt
import matplotlib.cm as cm
from scipy.spatial.distance import mahalanobis
from scipy import linalg
from scipy.signal import find_peaks
from blechpy.utils import memory_monitor as mm
from blechpy.plotting import blech_waveforms_datashader
from blechpy.dio import h5io
from blechpy.analysis import clustering as clust

def blech_clust_process(electrode_num, file_dir, params):

    print(&#39;Clustering electrode %i...&#39; % electrode_num)
    # Check if the directories for this electrode number exist - if they do, delete
    # them (existence of the directories indicates a job restart on the cluster, so
    # restart afresh), and make the directories
    fig_folders = [os.path.join(&#39;Plots&#39;,str(electrode_num)),
                   os.path.join(&#39;Plots&#39;,str(electrode_num),&#39;Plots&#39;),
                   os.path.join(&#39;spike_waveforms&#39;,&#39;electrode%i&#39; % electrode_num),
                   os.path.join(&#39;spike_times&#39;,&#39;electrode%i&#39; % electrode_num),
                   os.path.join(&#39;clustering_results&#39;,&#39;electrode%i&#39; % electrode_num)]

    for x in fig_folders:
        tmp_path = os.path.join(file_dir, x)
        if os.path.isdir(tmp_path):
            shutil.rmtree(tmp_path)

        os.mkdir(tmp_path)

    # Get the names of all files in the current directory, and find the .params and hdf5 (.h5) file
    file_list = os.listdir(file_dir)
    h5_file = h5io.get_h5_filename(file_dir)

    # Assign the parameters to variables
    max_clusters = params[&#39;clustering_params&#39;][&#39;Max Number of Clusters&#39;]
    num_iter = params[&#39;clustering_params&#39;][&#39;Max Number of Iterations&#39;]
    thresh = params[&#39;clustering_params&#39;][&#39;Convergence Criterion&#39;]
    num_restarts = params[&#39;clustering_params&#39;][&#39;GMM random restarts&#39;]
    voltage_cutoff = params[&#39;data_params&#39;][&#39;V_cutoff for disconnected headstage&#39;]
    max_breach_rate = params[&#39;data_params&#39;][&#39;Max rate of cutoff breach per second&#39;]
    max_secs_above_cutoff = params[&#39;data_params&#39;][&#39;Max allowed seconds with a breach&#39;]
    max_mean_breach_rate_persec = params[&#39;data_params&#39;][&#39;Max allowed breaches per second&#39;]
    wf_amplitude_sd_cutoff = params[&#39;data_params&#39;][&#39;Intra-cluster waveform amp SD cutoff&#39;]
    bandpass_lower_cutoff = params[&#39;bandpass_params&#39;][&#39;Lower freq cutoff&#39;]
    bandpass_upper_cutoff = params[&#39;bandpass_params&#39;][&#39;Upper freq cutoff&#39;]
    spike_snapshot_before = params[&#39;spike_snapshot&#39;][&#39;Time before spike (ms)&#39;]
    spike_snapshot_after = params[&#39;spike_snapshot&#39;][&#39;Time after spike (ms)&#39;]
    sampling_rate = params[&#39;sampling_rate&#39;]
    data_quality = params[&#39;data_quality&#39;]

    # Open up hdf5 file, and load this electrode number
    # Check if referenced data exists, if not grab raw
    raw_el = h5io.get_referenced_trace(file_dir, electrode_num)
    if raw_el is None:
        raw_el = h5io.get_raw_trace(file_dir, electrode_num)

    if raw_el is None:
        raise KeyError(&#39;Neither /raw/electrode{0} nor /referenced/electrode{0} found in {1}&#39;. \
                            format(electrode_num,hdf5_file))


    # High bandpass filter the raw electrode recordings
    filt_el = clust.get_filtered_electrode(raw_el, freq = [bandpass_lower_cutoff, bandpass_upper_cutoff], sampling_rate = sampling_rate)

    # Delete raw electrode recording from memory
    del raw_el

    # Calculate the 3 voltage parameters
    breach_rate = float(len(np.where(filt_el&gt;voltage_cutoff)[0])*int(sampling_rate))/len(filt_el)
    test_el = np.reshape(filt_el[:int(sampling_rate)*int(len(filt_el)/sampling_rate)], (-1, int(sampling_rate)))
    breaches_per_sec = [len(np.where(test_el[i] &gt; voltage_cutoff)[0]) for i in range(len(test_el))]
    breaches_per_sec = np.array(breaches_per_sec)
    secs_above_cutoff = len(np.where(breaches_per_sec &gt; 0)[0])
    if secs_above_cutoff == 0:
        mean_breach_rate_persec = 0
    else:
        mean_breach_rate_persec = np.mean(breaches_per_sec[np.where(breaches_per_sec &gt; 0)[0]])

    # And if they all exceed the cutoffs, assume that the headstage fell off mid-experiment
    recording_cutoff = int(len(filt_el)/sampling_rate)
    if breach_rate &gt;= max_breach_rate and secs_above_cutoff &gt;= max_secs_above_cutoff and mean_breach_rate_persec &gt;= max_mean_breach_rate_persec:
        # Find the first 1 second epoch where the number of cutoff breaches is higher than the maximum allowed mean breach rate 
        recording_cutoff = np.where(breaches_per_sec &gt; max_mean_breach_rate_persec)[0][0]

    # Dump a plot showing where the recording was cut off at
    fig = plt.figure()
    plt.plot(np.arange(test_el.shape[0]), np.mean(test_el, axis = 1))
    plt.plot((recording_cutoff, recording_cutoff), (np.min(np.mean(test_el, axis = 1)), np.max(np.mean(test_el, axis = 1))), &#39;k-&#39;, linewidth = 4.0)
    plt.xlabel(&#39;Recording time (secs)&#39;, fontsize=18)
    plt.ylabel(&#39;Average voltage recorded\nper sec (microvolts)&#39;, fontsize=18)
    plt.title(&#39;Recording cutoff time\n(indicated by the black horizontal line)&#39;, fontsize=18)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    save_file = os.path.join(file_dir,&#39;Plots&#39;,str(electrode_num),&#39;Plots&#39;,&#39;cutoff_time.png&#39;)
    fig.savefig(save_file, bbox_inches=&#39;tight&#39;)
    plt.close(&#34;all&#34;)

    # Then cut the recording accordingly
    filt_el = filt_el[:recording_cutoff*int(sampling_rate)]
    if len(filt_el)==0:
        print(&#39;Immediate Cutoff for electrode %i...exiting&#39; % electrode_num)
        return electrode_num, 0, recording_cutoff

    # Slice waveforms out of the filtered electrode recordings
    slices, spike_times = clust.extract_waveforms(filt_el, spike_snapshot = [spike_snapshot_before, spike_snapshot_after], sampling_rate = sampling_rate)
    if len(slices)==0:
        print(&#39;No spikes found for electrode %i...exiting&#39; % electrode_num)
        return electrode_num, 0, recording_cutoff

    # Delete filtered electrode from memory
    del filt_el, test_el

    # Dejitter these spike waveforms, and get their maximum amplitudes
    slices_dejittered, times_dejittered = clust.dejitter(slices, spike_times, spike_snapshot = [spike_snapshot_before, spike_snapshot_after], sampling_rate = sampling_rate)
    try:
        amplitudes = np.min(slices_dejittered, axis = 1)
    except:
        # This error triggers if slices dejittered have different lengths and thus cannot cast into 2D numpy array
        # Has been fixed in slices dejittered to throw out spikes whose minimum is
        # too close to the end of the waveform to get a full snapshot, happens only
        # for a few spikes since extract waveforms should make properly sized
        # waveforms around min, but not always
        print(&#39;Electrode %i slices_dejittered error: Dejitter shape %s &amp; slices shape %s&#39; % (electrode_num,str(slices_dejittered.shape),str(slices.shape)))
        return electrode_num, -1, recording_cutoff

    # Delete the original slices and times now that dejittering is complete
    del slices; del spike_times

    wave_dir = os.path.join(file_dir, &#39;spike_waveforms&#39;, &#39;electrode%i&#39; % electrode_num)
    time_dir = os.path.join(file_dir, &#39;spike_times&#39;, &#39;electrode%i&#39; % electrode_num)
    plot_dir = os.path.join(file_dir, &#39;Plots&#39;, &#39;%i&#39; % electrode_num, &#39;Plots&#39;)
    clust_dir = os.path.join(file_dir, &#39;clustering_results&#39;, &#39;electrode%i&#39; % electrode_num)
    # Save these slices/spike waveforms and their times to their respective folders
    np.save(os.path.join(wave_dir, &#39;spike_waveforms.npy&#39;), slices_dejittered)
    np.save(os.path.join(time_dir, &#39;spike_times.npy&#39;), times_dejittered)

    # Scale the dejittered slices by the energy of the waveforms
    scaled_slices, energy = clust.scale_waveforms(slices_dejittered)

    # Run PCA on the scaled waveforms
    pca_slices, explained_variance_ratio = clust.implement_pca(scaled_slices)

    # Save the pca_slices, energy and amplitudes to the spike_waveforms folder for this electrode
    np.save(os.path.join(wave_dir, &#39;pca_waveforms.npy&#39;), pca_slices)
    np.save(os.path.join(wave_dir, &#39;energy.npy&#39;), energy)
    np.save(os.path.join(wave_dir, &#39;spike_amplitudes.npy&#39;), amplitudes)


    # Create file for saving plots, and plot explained variance ratios of the PCA
    fig = plt.figure()
    x = np.arange(len(explained_variance_ratio))
    plt.plot(x, explained_variance_ratio)
    plt.title(&#39;Variance ratios explained by PCs&#39;,fontsize=26)
    plt.xlabel(&#39;PC #&#39;,fontsize=24)
    plt.ylabel(&#39;Explained variance ratio&#39;,fontsize=24)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    fig.savefig(os.path.join(plot_dir, &#39;pca_variance.png&#39;), bbox_inches=&#39;tight&#39;)
    plt.close(&#34;all&#34;)

    # Make an array of the data to be used for clustering, and delete pca_slices, scaled_slices, energy and amplitudes
    # Use trough to prior peak slope and the first 3 PCs
    n_pc = 3
    data = np.zeros((len(pca_slices), n_pc + 3))
    data[:,3:] = pca_slices[:,:n_pc]
    data[:,0] = energy[:]/np.max(energy)
    data[:,1] = np.abs(amplitudes)/np.max(np.abs(amplitudes))
    del pca_slices; del scaled_slices; del energy

    # Get slopes
    for i, wave in enumerate(slices_dejittered):
        peaks = find_peaks(wave)[0]
        minima = np.argmin(wave)
        if not any(peaks &lt; minima):
            maxima = np.argmax(wave[:minima])
        else:
            maxima = max(peaks[np.where(peaks &lt; minima)[0]])

        data[i,2] = (wave[minima]-wave[maxima])/(minima-maxima)


    # Run GMM, from 2 to max_clusters
    for i in range(max_clusters-1):
        try:
            model, predictions, bic = clust.clusterGMM(data, n_clusters = i+2, n_iter = num_iter, restarts = num_restarts, threshold = thresh)
        except:
            #print &#34;Clustering didn&#39;t work - solution with %i clusters most likely didn&#39;t converge&#34; % (i+2)
            continue

        # Sometimes large amplitude noise waveforms cluster with the spike waveforms because the amplitude has been factored out of the scaled slices.   
        # Run through the clusters and find the waveforms that are more than wf_amplitude_sd_cutoff larger than the cluster mean. Set predictions = -1 at these points so that they aren&#39;t picked up by blech_post_process
        for cluster in range(i+2):
            cluster_points = np.where(predictions[:] == cluster)[0]
            this_cluster = predictions[cluster_points]
            cluster_amplitudes = amplitudes[cluster_points]
            cluster_amplitude_mean = np.mean(cluster_amplitudes)
            cluster_amplitude_sd = np.std(cluster_amplitudes)
            reject_wf = np.where(cluster_amplitudes &lt;= cluster_amplitude_mean - wf_amplitude_sd_cutoff*cluster_amplitude_sd)[0]
            this_cluster[reject_wf] = -1
            predictions[cluster_points] = this_cluster

        # Make folder for results of i+2 clusters, and store results there
        tmp_clust_dir = os.path.join(clust_dir, &#39;clusters%i&#39; % (i+2))
        os.mkdir(tmp_clust_dir)
        np.save(os.path.join(tmp_clust_dir, &#39;predictions.npy&#39;), predictions)
        np.save(os.path.join(tmp_clust_dir, &#39;bic.npy&#39;), bic)

        # Plot the graphs, for this set of clusters, in the directory made for this electrode
        tmp_plot_dir = os.path.join(plot_dir, &#39;%i_clusters&#39; % (i+2))
        os.mkdir(tmp_plot_dir)
        colors = cm.rainbow(np.linspace(0, 1, i+2))

        for feature1 in range(len(data[0])):
            for feature2 in range(len(data[0])):
                if feature1 &lt; feature2:
                    fig = plt.figure()
                    plt_names = []
                    for cluster in range(i+2):
                        plot_data = np.where(predictions[:] == cluster)[0]
                        plt_names.append(plt.scatter(data[plot_data, feature1], data[plot_data, feature2], color = colors[cluster], s = 0.8))
                                            
                    plt.xlabel(&#34;Feature %i&#34; % feature1)
                    plt.ylabel(&#34;Feature %i&#34; % feature2)
                    # Produce figure legend
                    plt.legend(tuple(plt_names), tuple(&#34;Cluster %i&#34; % cluster for cluster in range(i+2)), scatterpoints = 1, loc = &#39;lower left&#39;, ncol = 3, fontsize = 8)
                    plt.title(&#34;%i clusters&#34; % (i+2))
                    plt.xticks(fontsize=14)
                    plt.yticks(fontsize=14)
                    fig.savefig(os.path.join(tmp_plot_dir, &#39;feature%ivs%i.png&#39; % (feature2, feature1)))
                    plt.close(&#34;all&#34;)

        for cluster in range(i+2):
            fig = plt.figure()
            cluster_points = np.where(predictions[:] == cluster)[0]
            
            for other_cluster in range(i+2):
                mahalanobis_dist = []
                other_cluster_mean = model.means_[other_cluster, :]
                other_cluster_covar_I = linalg.inv(model.covariances_[other_cluster, :, :])
                for points in cluster_points:
                     mahalanobis_dist.append(mahalanobis(data[points, :], other_cluster_mean, other_cluster_covar_I))
                # Plot histogram of Mahalanobis distances
                y,binEdges=np.histogram(mahalanobis_dist)
                bincenters = 0.5*(binEdges[1:] + binEdges[:-1])
                plt.plot(bincenters, y, label = &#39;Dist from cluster %i&#39; % other_cluster)    
                            
            plt.xlabel(&#39;Mahalanobis distance&#39;)
            plt.ylabel(&#39;Frequency&#39;)
            plt.legend(loc = &#39;upper right&#39;, fontsize = 8)
            plt.title(&#39;Mahalanobis distance of Cluster %i from all other clusters&#39; % cluster, fontsize=24)
            fig.savefig(os.path.join(tmp_plot_dir, &#39;Mahalonobis_cluster%i.png&#39; % cluster))
            plt.close(&#34;all&#34;)
        
        
        # Create file, and plot spike waveforms for the different clusters. Plot 10 times downsampled dejittered/smoothed waveforms.
        # Additionally plot the ISI distribution of each cluster 
        tmp_plot_dir = os.path.join(plot_dir, &#39;%i_clusters_waveforms_ISIs&#39; % (i+2))
        os.mkdir(tmp_plot_dir)
        for cluster in range(i+2):
            cluster_points = np.where(predictions[:] == cluster)[0]
            if cluster_points.shape[0] == 0:
                print(&#39;No cluster points for %s: electrode %i, cluster %i&#39; 
                      % (os.path.basename(file_dir), electrode_num, cluster))
                continue

            fig, ax = blech_waveforms_datashader.waveforms_datashader(slices_dejittered[cluster_points, :], dir_name = &#34;datashader_temp_el%i&#34; % electrode_num)
            ax.set_xlabel(&#39;Sample ({:d} samples per ms)&#39;.format(int(sampling_rate/1000)), fontsize=20)
            ax.set_ylabel(&#39;Voltage (microvolts)&#39;, fontsize=20)
            ax.set_title(&#39;Cluster%i&#39; % cluster, fontsize=26)
            plt.xticks(fontsize=14)
            plt.yticks(fontsize=14)
            fig.savefig(os.path.join(tmp_plot_dir, &#39;Cluster%i_waveforms&#39; % cluster))
            plt.close(&#34;all&#34;)
            
            fig = plt.figure()
            cluster_times = times_dejittered[cluster_points]
            ISIs = np.ediff1d(np.sort(cluster_times))
            ISIs = ISIs/(sampling_rate/1000)
            try:
                plt.hist(ISIs, bins = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, np.max(ISIs)])
            except:
                print(&#39;Electrode %i clustering %i has no ISIs: %s&#39; % (electrode_num,cluster,str(ISIs.shape)))
                return electrode_num, -1, recording_cutoff

            plt.xlim([0.0, 10.0])
            plt.title(&#34;2ms ISI violations = %.1f percent (%i/%i)&#34; %((float(len(np.where(ISIs &lt; 2.0)[0]))/float(len(cluster_times)))*100.0, len(np.where(ISIs &lt; 2.0)[0]), len(cluster_times)) + &#39;\n&#39; + &#34;1ms ISI violations = %.1f percent (%i/%i)&#34; %((float(len(np.where(ISIs &lt; 1.0)[0]))/float(len(cluster_times)))*100.0, len(np.where(ISIs &lt; 1.0)[0]), len(cluster_times)), fontsize=16)
            plt.xticks(fontsize=14)
            plt.yticks(fontsize=14)
            fig.savefig(os.path.join(tmp_plot_dir, &#39;Cluster%i_ISIs&#39; % cluster))
            plt.close(&#34;all&#34;)        

    # Make file for dumping info about memory usage
    f = open(os.path.join(file_dir, &#39;memory_monitor_clustering&#39;, &#39;%i.txt&#39; % electrode_num), &#39;w&#39;)
    print(mm.memory_usage_resource(), file=f)
    f.close()    
    print(&#39;Finished clustering electrode %i&#39; % electrode_num)
    return electrode_num, 1, recording_cutoff
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="blechpy.analysis.blech_clust_process.blech_clust_process"><code class="name flex">
<span>def <span class="ident">blech_clust_process</span></span>(<span>electrode_num, file_dir, params)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blech_clust_process(electrode_num, file_dir, params):

    print(&#39;Clustering electrode %i...&#39; % electrode_num)
    # Check if the directories for this electrode number exist - if they do, delete
    # them (existence of the directories indicates a job restart on the cluster, so
    # restart afresh), and make the directories
    fig_folders = [os.path.join(&#39;Plots&#39;,str(electrode_num)),
                   os.path.join(&#39;Plots&#39;,str(electrode_num),&#39;Plots&#39;),
                   os.path.join(&#39;spike_waveforms&#39;,&#39;electrode%i&#39; % electrode_num),
                   os.path.join(&#39;spike_times&#39;,&#39;electrode%i&#39; % electrode_num),
                   os.path.join(&#39;clustering_results&#39;,&#39;electrode%i&#39; % electrode_num)]

    for x in fig_folders:
        tmp_path = os.path.join(file_dir, x)
        if os.path.isdir(tmp_path):
            shutil.rmtree(tmp_path)

        os.mkdir(tmp_path)

    # Get the names of all files in the current directory, and find the .params and hdf5 (.h5) file
    file_list = os.listdir(file_dir)
    h5_file = h5io.get_h5_filename(file_dir)

    # Assign the parameters to variables
    max_clusters = params[&#39;clustering_params&#39;][&#39;Max Number of Clusters&#39;]
    num_iter = params[&#39;clustering_params&#39;][&#39;Max Number of Iterations&#39;]
    thresh = params[&#39;clustering_params&#39;][&#39;Convergence Criterion&#39;]
    num_restarts = params[&#39;clustering_params&#39;][&#39;GMM random restarts&#39;]
    voltage_cutoff = params[&#39;data_params&#39;][&#39;V_cutoff for disconnected headstage&#39;]
    max_breach_rate = params[&#39;data_params&#39;][&#39;Max rate of cutoff breach per second&#39;]
    max_secs_above_cutoff = params[&#39;data_params&#39;][&#39;Max allowed seconds with a breach&#39;]
    max_mean_breach_rate_persec = params[&#39;data_params&#39;][&#39;Max allowed breaches per second&#39;]
    wf_amplitude_sd_cutoff = params[&#39;data_params&#39;][&#39;Intra-cluster waveform amp SD cutoff&#39;]
    bandpass_lower_cutoff = params[&#39;bandpass_params&#39;][&#39;Lower freq cutoff&#39;]
    bandpass_upper_cutoff = params[&#39;bandpass_params&#39;][&#39;Upper freq cutoff&#39;]
    spike_snapshot_before = params[&#39;spike_snapshot&#39;][&#39;Time before spike (ms)&#39;]
    spike_snapshot_after = params[&#39;spike_snapshot&#39;][&#39;Time after spike (ms)&#39;]
    sampling_rate = params[&#39;sampling_rate&#39;]
    data_quality = params[&#39;data_quality&#39;]

    # Open up hdf5 file, and load this electrode number
    # Check if referenced data exists, if not grab raw
    raw_el = h5io.get_referenced_trace(file_dir, electrode_num)
    if raw_el is None:
        raw_el = h5io.get_raw_trace(file_dir, electrode_num)

    if raw_el is None:
        raise KeyError(&#39;Neither /raw/electrode{0} nor /referenced/electrode{0} found in {1}&#39;. \
                            format(electrode_num,hdf5_file))


    # High bandpass filter the raw electrode recordings
    filt_el = clust.get_filtered_electrode(raw_el, freq = [bandpass_lower_cutoff, bandpass_upper_cutoff], sampling_rate = sampling_rate)

    # Delete raw electrode recording from memory
    del raw_el

    # Calculate the 3 voltage parameters
    breach_rate = float(len(np.where(filt_el&gt;voltage_cutoff)[0])*int(sampling_rate))/len(filt_el)
    test_el = np.reshape(filt_el[:int(sampling_rate)*int(len(filt_el)/sampling_rate)], (-1, int(sampling_rate)))
    breaches_per_sec = [len(np.where(test_el[i] &gt; voltage_cutoff)[0]) for i in range(len(test_el))]
    breaches_per_sec = np.array(breaches_per_sec)
    secs_above_cutoff = len(np.where(breaches_per_sec &gt; 0)[0])
    if secs_above_cutoff == 0:
        mean_breach_rate_persec = 0
    else:
        mean_breach_rate_persec = np.mean(breaches_per_sec[np.where(breaches_per_sec &gt; 0)[0]])

    # And if they all exceed the cutoffs, assume that the headstage fell off mid-experiment
    recording_cutoff = int(len(filt_el)/sampling_rate)
    if breach_rate &gt;= max_breach_rate and secs_above_cutoff &gt;= max_secs_above_cutoff and mean_breach_rate_persec &gt;= max_mean_breach_rate_persec:
        # Find the first 1 second epoch where the number of cutoff breaches is higher than the maximum allowed mean breach rate 
        recording_cutoff = np.where(breaches_per_sec &gt; max_mean_breach_rate_persec)[0][0]

    # Dump a plot showing where the recording was cut off at
    fig = plt.figure()
    plt.plot(np.arange(test_el.shape[0]), np.mean(test_el, axis = 1))
    plt.plot((recording_cutoff, recording_cutoff), (np.min(np.mean(test_el, axis = 1)), np.max(np.mean(test_el, axis = 1))), &#39;k-&#39;, linewidth = 4.0)
    plt.xlabel(&#39;Recording time (secs)&#39;, fontsize=18)
    plt.ylabel(&#39;Average voltage recorded\nper sec (microvolts)&#39;, fontsize=18)
    plt.title(&#39;Recording cutoff time\n(indicated by the black horizontal line)&#39;, fontsize=18)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    save_file = os.path.join(file_dir,&#39;Plots&#39;,str(electrode_num),&#39;Plots&#39;,&#39;cutoff_time.png&#39;)
    fig.savefig(save_file, bbox_inches=&#39;tight&#39;)
    plt.close(&#34;all&#34;)

    # Then cut the recording accordingly
    filt_el = filt_el[:recording_cutoff*int(sampling_rate)]
    if len(filt_el)==0:
        print(&#39;Immediate Cutoff for electrode %i...exiting&#39; % electrode_num)
        return electrode_num, 0, recording_cutoff

    # Slice waveforms out of the filtered electrode recordings
    slices, spike_times = clust.extract_waveforms(filt_el, spike_snapshot = [spike_snapshot_before, spike_snapshot_after], sampling_rate = sampling_rate)
    if len(slices)==0:
        print(&#39;No spikes found for electrode %i...exiting&#39; % electrode_num)
        return electrode_num, 0, recording_cutoff

    # Delete filtered electrode from memory
    del filt_el, test_el

    # Dejitter these spike waveforms, and get their maximum amplitudes
    slices_dejittered, times_dejittered = clust.dejitter(slices, spike_times, spike_snapshot = [spike_snapshot_before, spike_snapshot_after], sampling_rate = sampling_rate)
    try:
        amplitudes = np.min(slices_dejittered, axis = 1)
    except:
        # This error triggers if slices dejittered have different lengths and thus cannot cast into 2D numpy array
        # Has been fixed in slices dejittered to throw out spikes whose minimum is
        # too close to the end of the waveform to get a full snapshot, happens only
        # for a few spikes since extract waveforms should make properly sized
        # waveforms around min, but not always
        print(&#39;Electrode %i slices_dejittered error: Dejitter shape %s &amp; slices shape %s&#39; % (electrode_num,str(slices_dejittered.shape),str(slices.shape)))
        return electrode_num, -1, recording_cutoff

    # Delete the original slices and times now that dejittering is complete
    del slices; del spike_times

    wave_dir = os.path.join(file_dir, &#39;spike_waveforms&#39;, &#39;electrode%i&#39; % electrode_num)
    time_dir = os.path.join(file_dir, &#39;spike_times&#39;, &#39;electrode%i&#39; % electrode_num)
    plot_dir = os.path.join(file_dir, &#39;Plots&#39;, &#39;%i&#39; % electrode_num, &#39;Plots&#39;)
    clust_dir = os.path.join(file_dir, &#39;clustering_results&#39;, &#39;electrode%i&#39; % electrode_num)
    # Save these slices/spike waveforms and their times to their respective folders
    np.save(os.path.join(wave_dir, &#39;spike_waveforms.npy&#39;), slices_dejittered)
    np.save(os.path.join(time_dir, &#39;spike_times.npy&#39;), times_dejittered)

    # Scale the dejittered slices by the energy of the waveforms
    scaled_slices, energy = clust.scale_waveforms(slices_dejittered)

    # Run PCA on the scaled waveforms
    pca_slices, explained_variance_ratio = clust.implement_pca(scaled_slices)

    # Save the pca_slices, energy and amplitudes to the spike_waveforms folder for this electrode
    np.save(os.path.join(wave_dir, &#39;pca_waveforms.npy&#39;), pca_slices)
    np.save(os.path.join(wave_dir, &#39;energy.npy&#39;), energy)
    np.save(os.path.join(wave_dir, &#39;spike_amplitudes.npy&#39;), amplitudes)


    # Create file for saving plots, and plot explained variance ratios of the PCA
    fig = plt.figure()
    x = np.arange(len(explained_variance_ratio))
    plt.plot(x, explained_variance_ratio)
    plt.title(&#39;Variance ratios explained by PCs&#39;,fontsize=26)
    plt.xlabel(&#39;PC #&#39;,fontsize=24)
    plt.ylabel(&#39;Explained variance ratio&#39;,fontsize=24)
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    fig.savefig(os.path.join(plot_dir, &#39;pca_variance.png&#39;), bbox_inches=&#39;tight&#39;)
    plt.close(&#34;all&#34;)

    # Make an array of the data to be used for clustering, and delete pca_slices, scaled_slices, energy and amplitudes
    # Use trough to prior peak slope and the first 3 PCs
    n_pc = 3
    data = np.zeros((len(pca_slices), n_pc + 3))
    data[:,3:] = pca_slices[:,:n_pc]
    data[:,0] = energy[:]/np.max(energy)
    data[:,1] = np.abs(amplitudes)/np.max(np.abs(amplitudes))
    del pca_slices; del scaled_slices; del energy

    # Get slopes
    for i, wave in enumerate(slices_dejittered):
        peaks = find_peaks(wave)[0]
        minima = np.argmin(wave)
        if not any(peaks &lt; minima):
            maxima = np.argmax(wave[:minima])
        else:
            maxima = max(peaks[np.where(peaks &lt; minima)[0]])

        data[i,2] = (wave[minima]-wave[maxima])/(minima-maxima)


    # Run GMM, from 2 to max_clusters
    for i in range(max_clusters-1):
        try:
            model, predictions, bic = clust.clusterGMM(data, n_clusters = i+2, n_iter = num_iter, restarts = num_restarts, threshold = thresh)
        except:
            #print &#34;Clustering didn&#39;t work - solution with %i clusters most likely didn&#39;t converge&#34; % (i+2)
            continue

        # Sometimes large amplitude noise waveforms cluster with the spike waveforms because the amplitude has been factored out of the scaled slices.   
        # Run through the clusters and find the waveforms that are more than wf_amplitude_sd_cutoff larger than the cluster mean. Set predictions = -1 at these points so that they aren&#39;t picked up by blech_post_process
        for cluster in range(i+2):
            cluster_points = np.where(predictions[:] == cluster)[0]
            this_cluster = predictions[cluster_points]
            cluster_amplitudes = amplitudes[cluster_points]
            cluster_amplitude_mean = np.mean(cluster_amplitudes)
            cluster_amplitude_sd = np.std(cluster_amplitudes)
            reject_wf = np.where(cluster_amplitudes &lt;= cluster_amplitude_mean - wf_amplitude_sd_cutoff*cluster_amplitude_sd)[0]
            this_cluster[reject_wf] = -1
            predictions[cluster_points] = this_cluster

        # Make folder for results of i+2 clusters, and store results there
        tmp_clust_dir = os.path.join(clust_dir, &#39;clusters%i&#39; % (i+2))
        os.mkdir(tmp_clust_dir)
        np.save(os.path.join(tmp_clust_dir, &#39;predictions.npy&#39;), predictions)
        np.save(os.path.join(tmp_clust_dir, &#39;bic.npy&#39;), bic)

        # Plot the graphs, for this set of clusters, in the directory made for this electrode
        tmp_plot_dir = os.path.join(plot_dir, &#39;%i_clusters&#39; % (i+2))
        os.mkdir(tmp_plot_dir)
        colors = cm.rainbow(np.linspace(0, 1, i+2))

        for feature1 in range(len(data[0])):
            for feature2 in range(len(data[0])):
                if feature1 &lt; feature2:
                    fig = plt.figure()
                    plt_names = []
                    for cluster in range(i+2):
                        plot_data = np.where(predictions[:] == cluster)[0]
                        plt_names.append(plt.scatter(data[plot_data, feature1], data[plot_data, feature2], color = colors[cluster], s = 0.8))
                                            
                    plt.xlabel(&#34;Feature %i&#34; % feature1)
                    plt.ylabel(&#34;Feature %i&#34; % feature2)
                    # Produce figure legend
                    plt.legend(tuple(plt_names), tuple(&#34;Cluster %i&#34; % cluster for cluster in range(i+2)), scatterpoints = 1, loc = &#39;lower left&#39;, ncol = 3, fontsize = 8)
                    plt.title(&#34;%i clusters&#34; % (i+2))
                    plt.xticks(fontsize=14)
                    plt.yticks(fontsize=14)
                    fig.savefig(os.path.join(tmp_plot_dir, &#39;feature%ivs%i.png&#39; % (feature2, feature1)))
                    plt.close(&#34;all&#34;)

        for cluster in range(i+2):
            fig = plt.figure()
            cluster_points = np.where(predictions[:] == cluster)[0]
            
            for other_cluster in range(i+2):
                mahalanobis_dist = []
                other_cluster_mean = model.means_[other_cluster, :]
                other_cluster_covar_I = linalg.inv(model.covariances_[other_cluster, :, :])
                for points in cluster_points:
                     mahalanobis_dist.append(mahalanobis(data[points, :], other_cluster_mean, other_cluster_covar_I))
                # Plot histogram of Mahalanobis distances
                y,binEdges=np.histogram(mahalanobis_dist)
                bincenters = 0.5*(binEdges[1:] + binEdges[:-1])
                plt.plot(bincenters, y, label = &#39;Dist from cluster %i&#39; % other_cluster)    
                            
            plt.xlabel(&#39;Mahalanobis distance&#39;)
            plt.ylabel(&#39;Frequency&#39;)
            plt.legend(loc = &#39;upper right&#39;, fontsize = 8)
            plt.title(&#39;Mahalanobis distance of Cluster %i from all other clusters&#39; % cluster, fontsize=24)
            fig.savefig(os.path.join(tmp_plot_dir, &#39;Mahalonobis_cluster%i.png&#39; % cluster))
            plt.close(&#34;all&#34;)
        
        
        # Create file, and plot spike waveforms for the different clusters. Plot 10 times downsampled dejittered/smoothed waveforms.
        # Additionally plot the ISI distribution of each cluster 
        tmp_plot_dir = os.path.join(plot_dir, &#39;%i_clusters_waveforms_ISIs&#39; % (i+2))
        os.mkdir(tmp_plot_dir)
        for cluster in range(i+2):
            cluster_points = np.where(predictions[:] == cluster)[0]
            if cluster_points.shape[0] == 0:
                print(&#39;No cluster points for %s: electrode %i, cluster %i&#39; 
                      % (os.path.basename(file_dir), electrode_num, cluster))
                continue

            fig, ax = blech_waveforms_datashader.waveforms_datashader(slices_dejittered[cluster_points, :], dir_name = &#34;datashader_temp_el%i&#34; % electrode_num)
            ax.set_xlabel(&#39;Sample ({:d} samples per ms)&#39;.format(int(sampling_rate/1000)), fontsize=20)
            ax.set_ylabel(&#39;Voltage (microvolts)&#39;, fontsize=20)
            ax.set_title(&#39;Cluster%i&#39; % cluster, fontsize=26)
            plt.xticks(fontsize=14)
            plt.yticks(fontsize=14)
            fig.savefig(os.path.join(tmp_plot_dir, &#39;Cluster%i_waveforms&#39; % cluster))
            plt.close(&#34;all&#34;)
            
            fig = plt.figure()
            cluster_times = times_dejittered[cluster_points]
            ISIs = np.ediff1d(np.sort(cluster_times))
            ISIs = ISIs/(sampling_rate/1000)
            try:
                plt.hist(ISIs, bins = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, np.max(ISIs)])
            except:
                print(&#39;Electrode %i clustering %i has no ISIs: %s&#39; % (electrode_num,cluster,str(ISIs.shape)))
                return electrode_num, -1, recording_cutoff

            plt.xlim([0.0, 10.0])
            plt.title(&#34;2ms ISI violations = %.1f percent (%i/%i)&#34; %((float(len(np.where(ISIs &lt; 2.0)[0]))/float(len(cluster_times)))*100.0, len(np.where(ISIs &lt; 2.0)[0]), len(cluster_times)) + &#39;\n&#39; + &#34;1ms ISI violations = %.1f percent (%i/%i)&#34; %((float(len(np.where(ISIs &lt; 1.0)[0]))/float(len(cluster_times)))*100.0, len(np.where(ISIs &lt; 1.0)[0]), len(cluster_times)), fontsize=16)
            plt.xticks(fontsize=14)
            plt.yticks(fontsize=14)
            fig.savefig(os.path.join(tmp_plot_dir, &#39;Cluster%i_ISIs&#39; % cluster))
            plt.close(&#34;all&#34;)        

    # Make file for dumping info about memory usage
    f = open(os.path.join(file_dir, &#39;memory_monitor_clustering&#39;, &#39;%i.txt&#39; % electrode_num), &#39;w&#39;)
    print(mm.memory_usage_resource(), file=f)
    f.close()    
    print(&#39;Finished clustering electrode %i&#39; % electrode_num)
    return electrode_num, 1, recording_cutoff</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="blechpy.analysis" href="index.html">blechpy.analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="blechpy.analysis.blech_clust_process.blech_clust_process" href="#blechpy.analysis.blech_clust_process.blech_clust_process">blech_clust_process</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>
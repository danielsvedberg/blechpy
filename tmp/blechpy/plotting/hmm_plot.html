<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>blechpy.plotting.hmm_plot API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>blechpy.plotting.hmm_plot</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import numpy as np
import pandas as pd
from scipy.ndimage import gaussian_filter1d
import matplotlib
matplotlib.use(&#39;TkAgg&#39;)
import pylab as plt
import seaborn as sns



def get_sequence_windows(seq):
    t = 0
    out = []
    while t &lt; len(seq):
        s = seq[t]
        tmp = np.where(seq[t:] != s)[0]
        if len(tmp) == 0:
            tmp = len(seq) - t
        else:
            tmp = tmp[0]

        out.append((t, tmp+t-1, s))
        t += tmp

    return out


def get_threshold_windows(trace, thresh=0.75):
    &#39;&#39;&#39;Returns list of tuples with start and stop time for windows where the
    given trace is above threshold. trace can be multiple rows. returns tuples
    in fashion (start_idx, stop_idx, row)
    &#39;&#39;&#39;
    out = []
    if len(trace.shape) == 1:
        trace = np.array([trace])

    n_rows, n_steps = trace.shape
    for i, row in enumerate(trace):
        t = 0
        while t &lt; n_steps:
            if row[t] &gt;= thresh:
                tmp = np.where(row[t:] &lt; thresh)[0]
            else:
                tmp = np.where(row[t:] &gt;= thresh)[0]

            if len(tmp) == 0:
                tmp = len(row) - t
            else:
                tmp = tmp[0]

            if row[t] &gt;= thresh:
                out.append((t, tmp+t-1, i))

            t += tmp

    return out


def get_hmm_plot_colors(n_states):
    colors = [plt.cm.tab10(x) for x in np.linspace(0, 1, n_states)]
    return colors


def plot_raster(spikes, time=None, ax=None, y_min=0.05, y_max=0.95):
    &#39;&#39;&#39;Plot 2D spike raster

    Parameters
    ----------
    spikes : np.array
        2D matrix M x N where N is the number of time steps and in each bin is
        a 0 or 1, with 1 signifying the presence of a spike
    &#39;&#39;&#39;
    if not ax:
        _, ax = plt.gca()

    n_rows, n_steps = spikes.shape
    if time is None:
        time = np.arange(0, n_steps)

    y_steps = np.linspace(y_min, y_max, n_rows)
    for i, row in enumerate(spikes):
        idx = np.where(row == 1)[0]
        if len(idx) == 0:
            continue

        ax.scatter(time[idx], row[idx]*y_steps[i], color=&#39;black&#39;, marker=&#39;|&#39;)

    return ax


def make_hmm_raster(spikes, time=None, save_file=None):
    &#39;&#39;&#39;Create figure of spikes rasters with each trial on a seperate axis

    Parameters
    ----------
    spikes: np.array, Trials X Cells X Time array with 1s where spikes occur
    time: np.array, 1D time vector
    save_file: str, if provided figure is saved and not returned

    Returns
    -------
    plt.Figure, list of plt.Axes
    &#39;&#39;&#39;
    if len(spikes) == 2:
        spikes = np.array([spikes])

    n_trials, n_cells, n_steps = spikes.shape
    if time is None:
        time = np.arange(0, n_steps)

    fig, axes = plt.subplots(nrows=n_trials, figsize=(15, n_trials))
    y_step = np.linspace(0.05, 0.95, n_cells)
    for ax, trial in zip(axes, spikes):
        tmp = plot_raster(trial, time=time, ax=ax)

        for spine in ax.spines.values():
            spine.set_visible(False)

        ax.get_yaxis().set_visible(False)
        ax.get_xaxis().set_visible(False)
        if time[0] &lt; 0:
            ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    axes[-1].get_xaxis().set_visible(True)
    tmp_ax = fig.add_subplot(&#39;111&#39;, frameon=False)
    tmp_ax.tick_params(labelcolor=&#39;none&#39;, top=False, bottom=False,
                       left=False, right=False)
    tmp_ax.set_ylabel(&#39;Trials&#39;)
    axes[-1].set_xlabel(&#39;Time&#39;)
    axes[-1].set_ylabel(&#39;Cells&#39;, fontsize=11)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes


def plot_sequence(seq, time=None, ax=None, y_min=0, y_max=1, colors=None):
    if ax is None:
        _, ax = plt.gca()

    if time is None:
        time = np.arange(0, len(seq))

    nStates = np.max(seq)+1
    if colors is None:
        colors = [plt.cm.Set2(x) for x in np.linspace(0, 1, nStates)]

    seq_windows = get_sequence_windows(seq)
    handles = {}
    for win in seq_windows:
        t_vec = [time[win[0]], time[win[1]]]
        h = ax.fill_between(t_vec, [y_min, y_min], [y_max, y_max],
                            color=colors[int(win[2])], alpha=0.4)
        if  win[2] not in handles:
            handles[win[2]] = h

    leg_handles = [handles[k] for k in sorted(handles.keys())]
    leg_labels = [&#39;State %i&#39; % k for k in sorted(handles.keys())]
    return ax, leg_handles, leg_labels


def plot_viterbi_paths(hmm, spikes, time=None, colors=None, axes=None, legend=True,
                       hmm_id=None, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend


    BIC = hmm.BIC
    paths = hmm.stat_arrays[&#39;best_sequences&#39;]
    n_trials, n_steps = paths.shape
    n_states = hmm.n_states
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(paths, axes):
        _, tmp_handles, tmp_labels = plot_sequence(trial, time=time, ax=ax, colors=colors)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

        if time[0] != 0:
            ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;Decoded HMM Sequences&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes


def plot_probability_traces(traces, time=None, ax=None, colors=None, thresh=0.75,
                           smoothing=3):
    y_min=0
    y_max=1
    if ax is None:
        _, ax = plt.gca()

    n_states, n_steps = traces.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0, 1, n_states)]

    windows = get_threshold_windows(traces, thresh=thresh)
    handles = {}
    for win in windows:
        t_vec = [time[win[0]], time[win[1]]]
        h = ax.fill_between(t_vec, [y_min, y_min], [y_max, y_max],
                            color=colors[int(win[2])], alpha=0.4)
        if  win[2] not in handles:
            handles[win[2]] = h

    leg_handles = [handles[k] for k in sorted(handles.keys())]
    leg_labels = [&#39;State %i&#39; % k for k in sorted(handles.keys())]

    for line, col in zip(traces, colors):
        tmp = line
        if smoothing:
            tmp = gaussian_filter1d(tmp, smoothing)

        ax.plot(time, tmp, color=col, linewidth=2)

    return ax, leg_handles, leg_labels


def plot_forward_probs(hmm, spikes, dt, time=None, colors=None, axes=None, legend=True,
                       hmm_id=None, thresh=0.75, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend

    alphas, norms = hmm.get_forward_probabilities(spikes, dt)
    n_trials, n_states, n_steps = alphas.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(alphas, axes):
        _, tmp_handles, tmp_labels = plot_probability_traces(trial,time=time, ax=ax,
                                                             colors=colors, thresh=thresh)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

    if time[0] != 0:
        ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;HMM Forward Probabilities&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes


def plot_backward_probs(hmm, spikes, dt, time=None, colors=None, axes=None, legend=True,
                        hmm_id=None, thresh=0.75, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend

    betas = hmm.get_backward_probabilities(spikes, dt)
    n_trials, n_states, n_steps = betas.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(betas, axes):
        _, tmp_handles, tmp_labels = plot_probability_traces(trial,time=time, ax=ax,
                                                             colors=colors, thresh=thresh)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

    if time[0] != 0:
        ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;HMM Backward Probabilities&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes


def plot_gamma_probs(hmm, spikes=None, dt=None, time=None, colors=None, axes=None, legend=True,
                     hmm_id=None, thresh=0.75, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend

    gammas = hmm.stat_arrays[&#39;gamma_probabilities&#39;]
    if gammas == []:
        if spikes is None and dt is None:
            raise ValueError(&#39;Not enough info to compute gamma probabilities&#39;)

        gammas = hmm.get_gamma_probabilities(spikes, dt)

    n_trials, n_states, n_steps = gammas.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(gammas, axes):
        _, tmp_handles, tmp_labels = plot_probability_traces(trial,time=time, ax=ax,
                                                             colors=colors, thresh=thresh)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

    if time[0] != 0:
        ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;HMM Gamma Probabilities&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        return
    else:
        return fig, axes


def plot_hmm_rates(rates, axes=None, colors=None):
    &#39;&#39;&#39;Make bar plot of spike rates for each cell and state in an HMM emission
    matrix

    Parameters
    ----------
    rates: np.array
        Cell X State matrix of firing rates
    &#39;&#39;&#39;
    n_cells, n_states = rates.shape
    if axes is None:
        _, axes = plt.subplot(ncols=n_states)

    if len(axes) &lt; n_states:
        raise ValueError(&#39;Must provided enough axes to plot each state&#39;)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    df = pd.DataFrame(rates, columns=[&#39;state %i&#39; % i for i in range(n_states)])
    df[&#39;cell&#39;] = [&#39;cell %i&#39; % i for i in df.index]
    df = pd.melt(df, &#39;cell&#39;, [&#39;state %i&#39; % i for i in range(n_states)], &#39;state&#39;, &#39;rate&#39;)
    x_max = 0
    for g, ax, col in zip(df.groupby(&#39;state&#39;), axes, colors):
        sns.barplot(data=g[1], x=&#39;rate&#39;, y=&#39;cell&#39;,
                    color=&#39;black&#39;, ax=ax)
        ax.set_title(g[0])
        ax.set_ylabel(&#39;&#39;)
        ax.set_xlabel(&#39;&#39;)
        ax.set_facecolor(col)
        ax.patch.set_alpha(0.5)
        ax.set_yticklabels([])
        ax.tick_params(left=False)
        xl = ax.get_xlim()
        if xl[1] &gt; x_max:
            x_max = xl[1]

        for spine in ax.spines.values():
            spine.set_visible(False)


    for ax in axes:
        ax.set_xlim([0, x_max])

    axes[0].set_yticklabels([&#39;Cell %i&#39; % i for i in range(n_cells)])
    mid = int(n_states/2)
    axes[mid].set_xlabel(&#39;Firing Rate (Hz)&#39;)
    return axes


def plot_hmm_transition(transition, ax=None):
    if not ax:
        _, ax = plt.gca()

    n_states = transition.shape[0]
    labels = [&#39;State %i&#39; % i for i in range(n_states)]
    sns.heatmap(transition, ax=ax, cmap=&#39;plasma&#39;, cbar=True, square=True,
                xticklabels=labels, yticklabels=labels, vmin=0, vmax=1,
                cbar_kws={&#39;shrink&#39;: 0.5})
    ax.set_ylim((0, n_states))
    ax.set_title(&#39;Transition Probabilities&#39;)
    return ax


def plot_hmm_initial_probs(PI, ax=None):
    if not ax:
        _ , ax = plt.gca()

    n_states = PI.shape[0]
    labels = [&#39;State %i&#39; % i for i in range(n_states)]
    PI = np.expand_dims(PI, 1)
    sns.heatmap(PI, ax=ax, cmap=&#39;plasma&#39;, cbar=True,
                yticklabels=labels, vmin=0, vmax=1)
    ax.set_ylim((0, n_states))
    ax.set_title(&#39;Initial Probabilities&#39;)
    return ax


def plot_hmm_overview(hmm, colors=None, hmm_id=None, save_file=None):
    n_states = hmm.n_states
    if not colors:
        colors = get_hmm_plot_colors(n_states)

    PI = hmm.initial_distribution
    A = hmm.transition
    B = hmm.emission
    fig, axes = plt.subplots(nrows=2, ncols=np.max((n_states,2)), figsize=(20, 15))
    if n_states &gt; 2:
        for ax in axes[0,1:-1]:
            ax.axis(&#39;off&#39;)

    plot_hmm_initial_probs(PI, ax=axes[0,0])
    plot_hmm_transition(A, ax=axes[0,-1])
    plot_hmm_rates(B, axes=axes[1,:], colors=colors)
    mid = int(n_states/2)
    axes[1, mid].set_xlabel(&#39;&#39;)
    tmp_ax = fig.add_subplot(&#39;111&#39;, frameon=False)
    tmp_ax.tick_params(labelcolor=&#39;none&#39;, top=False, bottom=False,
                       left=False, right=False)
    tmp_ax.set_xlabel(&#39;Firing Rate (Hz)&#39;)

    fig.subplots_adjust(top=0.9)
    title_str = &#39;Fitted HMM Parameters&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    fig.suptitle(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes


def plot_hmm_figures(hmm, spikes, dt, time, hmm_id=None, save_dir=None):
    colors = get_hmm_plot_colors(hmm.n_states)
    if hmm_id is None:
        hmm_id = hmm.hmm_id


    fig_names = [&#39;sequences&#39;, &#39;forward_probabilities&#39;,
                 &#39;backward_probabilities&#39;, &#39;gamma_probabilities&#39;, &#39;overview&#39;]
    if save_dir:
        files = {x : os.path.join(save_dir, &#39;%s.png&#39; % x) for x in fig_names}
    else:
        files = dict.fromkeys(fig_names, None)


    # Plot sequences
    print(&#39;Plotting Viterbi Decoded Paths...&#39;)
    plot_viterbi_paths(hmm, spikes, time=time, colors=colors,
                       hmm_id=hmm_id, save_file=files[&#39;sequences&#39;])

    # Plot alphas
    print(&#39;Plotting Forward Probabilities...&#39;)
    plot_forward_probs(hmm, spikes, dt, time=time, colors=colors,
                       hmm_id=hmm_id, save_file=files[&#39;forward_probabilities&#39;])
    # Plot betas
    print(&#39;Plotting Backward Probabilities...&#39;)
    plot_backward_probs(hmm, spikes, dt, time=time, colors=colors,
                        hmm_id=hmm_id, save_file=files[&#39;backward_probabilities&#39;])

    # Plot gammas
    print(&#39;Plotting Gamma Probabilities...&#39;)
    plot_gamma_probs(hmm, spikes, dt, time=time, colors=colors,
                     hmm_id=hmm_id, save_file=files[&#39;gamma_probabilities&#39;])

    # Plot stats: rate bar plots, transition heat map, initial probabilities
    print(&#39;Plotting HMM Overview...&#39;)
    plot_hmm_overview(hmm, colors=colors, save_file=files[&#39;overview&#39;])

    print(&#39;Plotting Complete!&#39;)
    plt.close(&#39;all&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="blechpy.plotting.hmm_plot.get_hmm_plot_colors"><code class="name flex">
<span>def <span class="ident">get_hmm_plot_colors</span></span>(<span>n_states)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hmm_plot_colors(n_states):
    colors = [plt.cm.tab10(x) for x in np.linspace(0, 1, n_states)]
    return colors</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.get_sequence_windows"><code class="name flex">
<span>def <span class="ident">get_sequence_windows</span></span>(<span>seq)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sequence_windows(seq):
    t = 0
    out = []
    while t &lt; len(seq):
        s = seq[t]
        tmp = np.where(seq[t:] != s)[0]
        if len(tmp) == 0:
            tmp = len(seq) - t
        else:
            tmp = tmp[0]

        out.append((t, tmp+t-1, s))
        t += tmp

    return out</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.get_threshold_windows"><code class="name flex">
<span>def <span class="ident">get_threshold_windows</span></span>(<span>trace, thresh=0.75)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns list of tuples with start and stop time for windows where the
given trace is above threshold. trace can be multiple rows. returns tuples
in fashion (start_idx, stop_idx, row)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_threshold_windows(trace, thresh=0.75):
    &#39;&#39;&#39;Returns list of tuples with start and stop time for windows where the
    given trace is above threshold. trace can be multiple rows. returns tuples
    in fashion (start_idx, stop_idx, row)
    &#39;&#39;&#39;
    out = []
    if len(trace.shape) == 1:
        trace = np.array([trace])

    n_rows, n_steps = trace.shape
    for i, row in enumerate(trace):
        t = 0
        while t &lt; n_steps:
            if row[t] &gt;= thresh:
                tmp = np.where(row[t:] &lt; thresh)[0]
            else:
                tmp = np.where(row[t:] &gt;= thresh)[0]

            if len(tmp) == 0:
                tmp = len(row) - t
            else:
                tmp = tmp[0]

            if row[t] &gt;= thresh:
                out.append((t, tmp+t-1, i))

            t += tmp

    return out</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.make_hmm_raster"><code class="name flex">
<span>def <span class="ident">make_hmm_raster</span></span>(<span>spikes, time=None, save_file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create figure of spikes rasters with each trial on a seperate axis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spikes</code></strong> :&ensp;<code>np.array, Trials X Cells X Time array with 1s where spikes occur</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>np.array, 1D time vector</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>save_file</code></strong> :&ensp;<code>str, if provided figure is saved and not returned</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plt.Figure, list</code> of <code>plt.Axes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_hmm_raster(spikes, time=None, save_file=None):
    &#39;&#39;&#39;Create figure of spikes rasters with each trial on a seperate axis

    Parameters
    ----------
    spikes: np.array, Trials X Cells X Time array with 1s where spikes occur
    time: np.array, 1D time vector
    save_file: str, if provided figure is saved and not returned

    Returns
    -------
    plt.Figure, list of plt.Axes
    &#39;&#39;&#39;
    if len(spikes) == 2:
        spikes = np.array([spikes])

    n_trials, n_cells, n_steps = spikes.shape
    if time is None:
        time = np.arange(0, n_steps)

    fig, axes = plt.subplots(nrows=n_trials, figsize=(15, n_trials))
    y_step = np.linspace(0.05, 0.95, n_cells)
    for ax, trial in zip(axes, spikes):
        tmp = plot_raster(trial, time=time, ax=ax)

        for spine in ax.spines.values():
            spine.set_visible(False)

        ax.get_yaxis().set_visible(False)
        ax.get_xaxis().set_visible(False)
        if time[0] &lt; 0:
            ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    axes[-1].get_xaxis().set_visible(True)
    tmp_ax = fig.add_subplot(&#39;111&#39;, frameon=False)
    tmp_ax.tick_params(labelcolor=&#39;none&#39;, top=False, bottom=False,
                       left=False, right=False)
    tmp_ax.set_ylabel(&#39;Trials&#39;)
    axes[-1].set_xlabel(&#39;Time&#39;)
    axes[-1].set_ylabel(&#39;Cells&#39;, fontsize=11)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_backward_probs"><code class="name flex">
<span>def <span class="ident">plot_backward_probs</span></span>(<span>hmm, spikes, dt, time=None, colors=None, axes=None, legend=True, hmm_id=None, thresh=0.75, save_file=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_backward_probs(hmm, spikes, dt, time=None, colors=None, axes=None, legend=True,
                        hmm_id=None, thresh=0.75, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend

    betas = hmm.get_backward_probabilities(spikes, dt)
    n_trials, n_states, n_steps = betas.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(betas, axes):
        _, tmp_handles, tmp_labels = plot_probability_traces(trial,time=time, ax=ax,
                                                             colors=colors, thresh=thresh)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

    if time[0] != 0:
        ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;HMM Backward Probabilities&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_forward_probs"><code class="name flex">
<span>def <span class="ident">plot_forward_probs</span></span>(<span>hmm, spikes, dt, time=None, colors=None, axes=None, legend=True, hmm_id=None, thresh=0.75, save_file=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_forward_probs(hmm, spikes, dt, time=None, colors=None, axes=None, legend=True,
                       hmm_id=None, thresh=0.75, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend

    alphas, norms = hmm.get_forward_probabilities(spikes, dt)
    n_trials, n_states, n_steps = alphas.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(alphas, axes):
        _, tmp_handles, tmp_labels = plot_probability_traces(trial,time=time, ax=ax,
                                                             colors=colors, thresh=thresh)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

    if time[0] != 0:
        ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;HMM Forward Probabilities&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_gamma_probs"><code class="name flex">
<span>def <span class="ident">plot_gamma_probs</span></span>(<span>hmm, spikes=None, dt=None, time=None, colors=None, axes=None, legend=True, hmm_id=None, thresh=0.75, save_file=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_gamma_probs(hmm, spikes=None, dt=None, time=None, colors=None, axes=None, legend=True,
                     hmm_id=None, thresh=0.75, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend

    gammas = hmm.stat_arrays[&#39;gamma_probabilities&#39;]
    if gammas == []:
        if spikes is None and dt is None:
            raise ValueError(&#39;Not enough info to compute gamma probabilities&#39;)

        gammas = hmm.get_gamma_probabilities(spikes, dt)

    n_trials, n_states, n_steps = gammas.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(gammas, axes):
        _, tmp_handles, tmp_labels = plot_probability_traces(trial,time=time, ax=ax,
                                                             colors=colors, thresh=thresh)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

    if time[0] != 0:
        ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;HMM Gamma Probabilities&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        return
    else:
        return fig, axes</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_hmm_figures"><code class="name flex">
<span>def <span class="ident">plot_hmm_figures</span></span>(<span>hmm, spikes, dt, time, hmm_id=None, save_dir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hmm_figures(hmm, spikes, dt, time, hmm_id=None, save_dir=None):
    colors = get_hmm_plot_colors(hmm.n_states)
    if hmm_id is None:
        hmm_id = hmm.hmm_id


    fig_names = [&#39;sequences&#39;, &#39;forward_probabilities&#39;,
                 &#39;backward_probabilities&#39;, &#39;gamma_probabilities&#39;, &#39;overview&#39;]
    if save_dir:
        files = {x : os.path.join(save_dir, &#39;%s.png&#39; % x) for x in fig_names}
    else:
        files = dict.fromkeys(fig_names, None)


    # Plot sequences
    print(&#39;Plotting Viterbi Decoded Paths...&#39;)
    plot_viterbi_paths(hmm, spikes, time=time, colors=colors,
                       hmm_id=hmm_id, save_file=files[&#39;sequences&#39;])

    # Plot alphas
    print(&#39;Plotting Forward Probabilities...&#39;)
    plot_forward_probs(hmm, spikes, dt, time=time, colors=colors,
                       hmm_id=hmm_id, save_file=files[&#39;forward_probabilities&#39;])
    # Plot betas
    print(&#39;Plotting Backward Probabilities...&#39;)
    plot_backward_probs(hmm, spikes, dt, time=time, colors=colors,
                        hmm_id=hmm_id, save_file=files[&#39;backward_probabilities&#39;])

    # Plot gammas
    print(&#39;Plotting Gamma Probabilities...&#39;)
    plot_gamma_probs(hmm, spikes, dt, time=time, colors=colors,
                     hmm_id=hmm_id, save_file=files[&#39;gamma_probabilities&#39;])

    # Plot stats: rate bar plots, transition heat map, initial probabilities
    print(&#39;Plotting HMM Overview...&#39;)
    plot_hmm_overview(hmm, colors=colors, save_file=files[&#39;overview&#39;])

    print(&#39;Plotting Complete!&#39;)
    plt.close(&#39;all&#39;)</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_hmm_initial_probs"><code class="name flex">
<span>def <span class="ident">plot_hmm_initial_probs</span></span>(<span>PI, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hmm_initial_probs(PI, ax=None):
    if not ax:
        _ , ax = plt.gca()

    n_states = PI.shape[0]
    labels = [&#39;State %i&#39; % i for i in range(n_states)]
    PI = np.expand_dims(PI, 1)
    sns.heatmap(PI, ax=ax, cmap=&#39;plasma&#39;, cbar=True,
                yticklabels=labels, vmin=0, vmax=1)
    ax.set_ylim((0, n_states))
    ax.set_title(&#39;Initial Probabilities&#39;)
    return ax</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_hmm_overview"><code class="name flex">
<span>def <span class="ident">plot_hmm_overview</span></span>(<span>hmm, colors=None, hmm_id=None, save_file=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hmm_overview(hmm, colors=None, hmm_id=None, save_file=None):
    n_states = hmm.n_states
    if not colors:
        colors = get_hmm_plot_colors(n_states)

    PI = hmm.initial_distribution
    A = hmm.transition
    B = hmm.emission
    fig, axes = plt.subplots(nrows=2, ncols=np.max((n_states,2)), figsize=(20, 15))
    if n_states &gt; 2:
        for ax in axes[0,1:-1]:
            ax.axis(&#39;off&#39;)

    plot_hmm_initial_probs(PI, ax=axes[0,0])
    plot_hmm_transition(A, ax=axes[0,-1])
    plot_hmm_rates(B, axes=axes[1,:], colors=colors)
    mid = int(n_states/2)
    axes[1, mid].set_xlabel(&#39;&#39;)
    tmp_ax = fig.add_subplot(&#39;111&#39;, frameon=False)
    tmp_ax.tick_params(labelcolor=&#39;none&#39;, top=False, bottom=False,
                       left=False, right=False)
    tmp_ax.set_xlabel(&#39;Firing Rate (Hz)&#39;)

    fig.subplots_adjust(top=0.9)
    title_str = &#39;Fitted HMM Parameters&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    fig.suptitle(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_hmm_rates"><code class="name flex">
<span>def <span class="ident">plot_hmm_rates</span></span>(<span>rates, axes=None, colors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make bar plot of spike rates for each cell and state in an HMM emission
matrix</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rates</code></strong> :&ensp;<code>np.array</code></dt>
<dd>Cell X State matrix of firing rates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hmm_rates(rates, axes=None, colors=None):
    &#39;&#39;&#39;Make bar plot of spike rates for each cell and state in an HMM emission
    matrix

    Parameters
    ----------
    rates: np.array
        Cell X State matrix of firing rates
    &#39;&#39;&#39;
    n_cells, n_states = rates.shape
    if axes is None:
        _, axes = plt.subplot(ncols=n_states)

    if len(axes) &lt; n_states:
        raise ValueError(&#39;Must provided enough axes to plot each state&#39;)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    df = pd.DataFrame(rates, columns=[&#39;state %i&#39; % i for i in range(n_states)])
    df[&#39;cell&#39;] = [&#39;cell %i&#39; % i for i in df.index]
    df = pd.melt(df, &#39;cell&#39;, [&#39;state %i&#39; % i for i in range(n_states)], &#39;state&#39;, &#39;rate&#39;)
    x_max = 0
    for g, ax, col in zip(df.groupby(&#39;state&#39;), axes, colors):
        sns.barplot(data=g[1], x=&#39;rate&#39;, y=&#39;cell&#39;,
                    color=&#39;black&#39;, ax=ax)
        ax.set_title(g[0])
        ax.set_ylabel(&#39;&#39;)
        ax.set_xlabel(&#39;&#39;)
        ax.set_facecolor(col)
        ax.patch.set_alpha(0.5)
        ax.set_yticklabels([])
        ax.tick_params(left=False)
        xl = ax.get_xlim()
        if xl[1] &gt; x_max:
            x_max = xl[1]

        for spine in ax.spines.values():
            spine.set_visible(False)


    for ax in axes:
        ax.set_xlim([0, x_max])

    axes[0].set_yticklabels([&#39;Cell %i&#39; % i for i in range(n_cells)])
    mid = int(n_states/2)
    axes[mid].set_xlabel(&#39;Firing Rate (Hz)&#39;)
    return axes</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_hmm_transition"><code class="name flex">
<span>def <span class="ident">plot_hmm_transition</span></span>(<span>transition, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_hmm_transition(transition, ax=None):
    if not ax:
        _, ax = plt.gca()

    n_states = transition.shape[0]
    labels = [&#39;State %i&#39; % i for i in range(n_states)]
    sns.heatmap(transition, ax=ax, cmap=&#39;plasma&#39;, cbar=True, square=True,
                xticklabels=labels, yticklabels=labels, vmin=0, vmax=1,
                cbar_kws={&#39;shrink&#39;: 0.5})
    ax.set_ylim((0, n_states))
    ax.set_title(&#39;Transition Probabilities&#39;)
    return ax</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_probability_traces"><code class="name flex">
<span>def <span class="ident">plot_probability_traces</span></span>(<span>traces, time=None, ax=None, colors=None, thresh=0.75, smoothing=3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_probability_traces(traces, time=None, ax=None, colors=None, thresh=0.75,
                           smoothing=3):
    y_min=0
    y_max=1
    if ax is None:
        _, ax = plt.gca()

    n_states, n_steps = traces.shape
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0, 1, n_states)]

    windows = get_threshold_windows(traces, thresh=thresh)
    handles = {}
    for win in windows:
        t_vec = [time[win[0]], time[win[1]]]
        h = ax.fill_between(t_vec, [y_min, y_min], [y_max, y_max],
                            color=colors[int(win[2])], alpha=0.4)
        if  win[2] not in handles:
            handles[win[2]] = h

    leg_handles = [handles[k] for k in sorted(handles.keys())]
    leg_labels = [&#39;State %i&#39; % k for k in sorted(handles.keys())]

    for line, col in zip(traces, colors):
        tmp = line
        if smoothing:
            tmp = gaussian_filter1d(tmp, smoothing)

        ax.plot(time, tmp, color=col, linewidth=2)

    return ax, leg_handles, leg_labels</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_raster"><code class="name flex">
<span>def <span class="ident">plot_raster</span></span>(<span>spikes, time=None, ax=None, y_min=0.05, y_max=0.95)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot 2D spike raster</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spikes</code></strong> :&ensp;<code>np.array</code></dt>
<dd>2D matrix M x N where N is the number of time steps and in each bin is
a 0 or 1, with 1 signifying the presence of a spike</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_raster(spikes, time=None, ax=None, y_min=0.05, y_max=0.95):
    &#39;&#39;&#39;Plot 2D spike raster

    Parameters
    ----------
    spikes : np.array
        2D matrix M x N where N is the number of time steps and in each bin is
        a 0 or 1, with 1 signifying the presence of a spike
    &#39;&#39;&#39;
    if not ax:
        _, ax = plt.gca()

    n_rows, n_steps = spikes.shape
    if time is None:
        time = np.arange(0, n_steps)

    y_steps = np.linspace(y_min, y_max, n_rows)
    for i, row in enumerate(spikes):
        idx = np.where(row == 1)[0]
        if len(idx) == 0:
            continue

        ax.scatter(time[idx], row[idx]*y_steps[i], color=&#39;black&#39;, marker=&#39;|&#39;)

    return ax</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_sequence"><code class="name flex">
<span>def <span class="ident">plot_sequence</span></span>(<span>seq, time=None, ax=None, y_min=0, y_max=1, colors=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_sequence(seq, time=None, ax=None, y_min=0, y_max=1, colors=None):
    if ax is None:
        _, ax = plt.gca()

    if time is None:
        time = np.arange(0, len(seq))

    nStates = np.max(seq)+1
    if colors is None:
        colors = [plt.cm.Set2(x) for x in np.linspace(0, 1, nStates)]

    seq_windows = get_sequence_windows(seq)
    handles = {}
    for win in seq_windows:
        t_vec = [time[win[0]], time[win[1]]]
        h = ax.fill_between(t_vec, [y_min, y_min], [y_max, y_max],
                            color=colors[int(win[2])], alpha=0.4)
        if  win[2] not in handles:
            handles[win[2]] = h

    leg_handles = [handles[k] for k in sorted(handles.keys())]
    leg_labels = [&#39;State %i&#39; % k for k in sorted(handles.keys())]
    return ax, leg_handles, leg_labels</code></pre>
</details>
</dd>
<dt id="blechpy.plotting.hmm_plot.plot_viterbi_paths"><code class="name flex">
<span>def <span class="ident">plot_viterbi_paths</span></span>(<span>hmm, spikes, time=None, colors=None, axes=None, legend=True, hmm_id=None, save_file=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_viterbi_paths(hmm, spikes, time=None, colors=None, axes=None, legend=True,
                       hmm_id=None, save_file=None):
    if not axes:
        fig, axes = make_hmm_raster(spikes, time=time)
    else:
        fig = axes[0].figure

    if legend:
        fig.subplots_adjust(right=0.9)  # To  make room for legend


    BIC = hmm.BIC
    paths = hmm.stat_arrays[&#39;best_sequences&#39;]
    n_trials, n_steps = paths.shape
    n_states = hmm.n_states
    if time is None:
        time = np.arange(0, n_steps)

    if not colors:
        colors = [plt.cm.Set2(x) for x in np.linspace(0,1, n_states)]

    handles = []
    labels = []
    for trial, ax in zip(paths, axes):
        _, tmp_handles, tmp_labels = plot_sequence(trial, time=time, ax=ax, colors=colors)
        for l, h in zip(tmp_labels, tmp_handles):
            if l not in labels:
                handles.append(h)
                labels.append(l)

        if time[0] != 0:
            ax.axvline(0, color=&#39;red&#39;, linestyle=&#39;--&#39;, linewidth=3, alpha=0.8)

    if legend:
        mid = int(n_trials/2)
        axes[mid].legend(handles, labels, loc=&#39;upper center&#39;,
                         bbox_to_anchor=(0.8, .5, .5, .5), shadow=True,
                         fontsize=14)

    axes[-1].set_xlabel(&#39;Time (ms)&#39;)
    title_str = &#39;Decoded HMM Sequences&#39;
    if hmm_id:
        title_str += &#39;\n%s&#39; % hmm_id

    axes[0].set_title(title_str)
    if save_file:
        fig.savefig(save_file)
        plt.close(fig)
        return
    else:
        return fig, axes</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="blechpy.plotting" href="index.html">blechpy.plotting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="blechpy.plotting.hmm_plot.get_hmm_plot_colors" href="#blechpy.plotting.hmm_plot.get_hmm_plot_colors">get_hmm_plot_colors</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.get_sequence_windows" href="#blechpy.plotting.hmm_plot.get_sequence_windows">get_sequence_windows</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.get_threshold_windows" href="#blechpy.plotting.hmm_plot.get_threshold_windows">get_threshold_windows</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.make_hmm_raster" href="#blechpy.plotting.hmm_plot.make_hmm_raster">make_hmm_raster</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_backward_probs" href="#blechpy.plotting.hmm_plot.plot_backward_probs">plot_backward_probs</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_forward_probs" href="#blechpy.plotting.hmm_plot.plot_forward_probs">plot_forward_probs</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_gamma_probs" href="#blechpy.plotting.hmm_plot.plot_gamma_probs">plot_gamma_probs</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_hmm_figures" href="#blechpy.plotting.hmm_plot.plot_hmm_figures">plot_hmm_figures</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_hmm_initial_probs" href="#blechpy.plotting.hmm_plot.plot_hmm_initial_probs">plot_hmm_initial_probs</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_hmm_overview" href="#blechpy.plotting.hmm_plot.plot_hmm_overview">plot_hmm_overview</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_hmm_rates" href="#blechpy.plotting.hmm_plot.plot_hmm_rates">plot_hmm_rates</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_hmm_transition" href="#blechpy.plotting.hmm_plot.plot_hmm_transition">plot_hmm_transition</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_probability_traces" href="#blechpy.plotting.hmm_plot.plot_probability_traces">plot_probability_traces</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_raster" href="#blechpy.plotting.hmm_plot.plot_raster">plot_raster</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_sequence" href="#blechpy.plotting.hmm_plot.plot_sequence">plot_sequence</a></code></li>
<li><code><a title="blechpy.plotting.hmm_plot.plot_viterbi_paths" href="#blechpy.plotting.hmm_plot.plot_viterbi_paths">plot_viterbi_paths</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>